{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/typing/source/CNAME","path":"CNAME","modified":1,"renderable":1},{"_id":"themes/typing/source/js/typing.js","path":"js/typing.js","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/typing/source/css/source.css","path":"css/source.css","modified":1,"renderable":1},{"_id":"themes/typing/source/css/typing.css","path":"css/typing.css","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"8dad7d38a5af2657387ce99e7397fa87d5c5e669","modified":1487151789000},{"_id":"themes/typing/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1487137383000},{"_id":"themes/typing/.gitignore","hash":"d83e98433e68316c1ba1260e46463447ad71aaa1","modified":1487137383000},{"_id":"themes/typing/.DS_Store","hash":"8b7839202cc88baef733babb01c8ed96fe4ae93f","modified":1487144009000},{"_id":"themes/typing/README.md","hash":"d7670e510da9405bb8b95a980aa1ca36a5da4901","modified":1487137383000},{"_id":"themes/typing/LICENSE","hash":"e4bf48251989dd666899d2d22b351b8db4764992","modified":1487137383000},{"_id":"themes/typing/_config.yml","hash":"db74bea9196bef159b9eb0424f9fc9c5cd01cbcc","modified":1487142672000},{"_id":"themes/typing/makefile","hash":"5c63c52a6c85ce3d88ad41d4772f228899c1f504","modified":1487137383000},{"_id":"themes/typing/package.json","hash":"262a12df885c9eb894560d7f0cf7ca6315821953","modified":1487137383000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1487144829000},{"_id":"source/_posts/Android事件分发机制.md","hash":"6be4bc1ffc7e1b187feb5c8e8c2a2810036a1510","modified":1487145801000},{"_id":"source/_posts/SDK开发学习小结.md","hash":"a1cf6e4815a3dd006ab87ffbf1ef78b5f6f2bd19","modified":1487146157000},{"_id":"source/_posts/Android-Gradle.md","hash":"708db0279202cb76af5d73a4f56770acea6cd4ac","modified":1487145319000},{"_id":"source/_posts/canvas.md","hash":"f70c8c83df44a97ef66baa94f478149e97a3d418","modified":1487145182000},{"_id":"source/_posts/git常用命令行.md","hash":"3a17310116e8550057dc9bc3b3b11e91e7326bfb","modified":1487145626000},{"_id":"source/_posts/bitmap.md","hash":"6319ac3f9dc362a1ae89a579cf47e8c9062c7a02","modified":1487144765000},{"_id":"source/_posts/adb命令.md","hash":"2a4fb555bf041b1d549e529a8f9f9c30b4bca482","modified":1487145571000},{"_id":"source/_posts/so文件.md","hash":"0e06b869d89eaa6b887099981db0b84bf2d67a6d","modified":1487145488000},{"_id":"source/_posts/单例模式.md","hash":"32cf1c89618a12a0e15eb5691d24350553fa4e40","modified":1487145431000},{"_id":"source/_posts/读《Android开发艺术探索》笔记.md","hash":"c8bb1e54ab7ac941dbd914f8cd9fba36ac3a2e88","modified":1487146047000},{"_id":"source/_posts/开发中遇到的坑.md","hash":"715b7e3ac002b1e86436287657c4e04bc5f8fe2a","modified":1487146723000},{"_id":"source/about/index.md","hash":"6471cd2e362e0e74580464f810293f0bd17b9c79","modified":1487151771000},{"_id":"themes/typing/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1487137383000},{"_id":"themes/typing/.git/config","hash":"39cfef7ee7adcc7a9f129fd228462a2c412a0073","modified":1487137383000},{"_id":"themes/typing/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1487137369000},{"_id":"themes/typing/.git/index","hash":"8a09272dc02b219e367af723fe949a04bd7b9a88","modified":1487139852000},{"_id":"themes/typing/.git/packed-refs","hash":"75ea4bcf4472aa3da67767f2647a14fa7d1cba1c","modified":1487137383000},{"_id":"themes/typing/languages/es.yml","hash":"23dc21c62927062829e31fcfd6c5d2c7e9257844","modified":1487137383000},{"_id":"themes/typing/languages/default.yml","hash":"bd8e9329c5636b85bc554b76f06830269869864d","modified":1487137383000},{"_id":"themes/typing/languages/nl.yml","hash":"95fc8003c34e1353f73f6315291d0cb10b5d7e73","modified":1487137383000},{"_id":"themes/typing/languages/ru.yml","hash":"3d45b446862c8a305823533b868556f6111308fe","modified":1487137383000},{"_id":"themes/typing/languages/no.yml","hash":"53ba8ffd6353262138016bd1b4c3a65a113e6c52","modified":1487137383000},{"_id":"themes/typing/languages/fr.yml","hash":"559b094ef6b9d02506c33044be8b50ebeda28a70","modified":1487137383000},{"_id":"themes/typing/languages/zh-CN.yml","hash":"4f227318cce98303496e423d85de28b79fb01f00","modified":1487137383000},{"_id":"themes/typing/languages/zh-TW.yml","hash":"b68f12091eeae30b56847997d059f5ce29f086ac","modified":1487137383000},{"_id":"themes/typing/source/.DS_Store","hash":"4ec9fa1308477baff435caaa33e55b5a641f9b00","modified":1487143771000},{"_id":"themes/typing/source/CNAME","hash":"6550d948097fa5413ef41cd764ba208bafaf185a","modified":1482385077000},{"_id":"themes/typing/layout/.DS_Store","hash":"08a1b17f850059d18759b3e71604904807708396","modified":1487143516000},{"_id":"themes/typing/layout/index.ejs","hash":"18aaf3d920f7cae080932a909640754d69bbee1b","modified":1487137383000},{"_id":"themes/typing/layout/layout.ejs","hash":"595a9150e0184ae221589ca6b454f3a9475591c6","modified":1487137383000},{"_id":"themes/typing/layout/category.ejs","hash":"a6f14dc7f869d6cd0663fef8747c708cdbb18fe7","modified":1487137383000},{"_id":"themes/typing/layout/archive.ejs","hash":"1326b972ea3dcdc23a453e3c61709ffe561ed931","modified":1487137383000},{"_id":"themes/typing/layout/post.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1487137383000},{"_id":"themes/typing/layout/tag.ejs","hash":"b9558a0789e3549d6bbcaf86544af9bd3a7a472a","modified":1487137383000},{"_id":"themes/typing/layout/page.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1487137383000},{"_id":"themes/typing/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1487137369000},{"_id":"themes/typing/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1487137369000},{"_id":"themes/typing/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1487137369000},{"_id":"themes/typing/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1487137369000},{"_id":"themes/typing/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1487137369000},{"_id":"themes/typing/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1487137369000},{"_id":"themes/typing/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1487137369000},{"_id":"themes/typing/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1487137369000},{"_id":"themes/typing/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1487137369000},{"_id":"themes/typing/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1487137369000},{"_id":"themes/typing/.git/logs/HEAD","hash":"d09f8ac067a5532e4047e645a128f4781d788131","modified":1487137383000},{"_id":"themes/typing/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1487137369000},{"_id":"themes/typing/source/js/typing.js","hash":"e1de54745c5df13cc207ca4bd2e4e02b2e5a31be","modified":1487137383000},{"_id":"themes/typing/preview/preview.png","hash":"33b39c8a626db45ee473ce3e3d0e37ebd9fb83d3","modified":1487137383000},{"_id":"themes/typing/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1487137383000},{"_id":"themes/typing/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1487137383000},{"_id":"themes/typing/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1487137383000},{"_id":"themes/typing/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487137383000},{"_id":"themes/typing/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1487137383000},{"_id":"themes/typing/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487137383000},{"_id":"themes/typing/source/fancybox/.DS_Store","hash":"43d833ac371775098397da789e4fa7e0e624f946","modified":1487143781000},{"_id":"themes/typing/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1487137383000},{"_id":"themes/typing/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1487137383000},{"_id":"themes/typing/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1487137383000},{"_id":"themes/typing/source/css/source.css","hash":"93078434d298038b963c165b31a497cc517b0baf","modified":1487137383000},{"_id":"themes/typing/source/css/typing.css","hash":"eab2f172f9fb44d460babc971b42dca92eef3e3b","modified":1487137383000},{"_id":"themes/typing/layout/_partial/.DS_Store","hash":"0af4458db0eb004a5a78c033931219532df46e65","modified":1487143521000},{"_id":"themes/typing/layout/_partial/after-footer.ejs","hash":"7737fd36dffa21abdc1894413d4063d36edba5e7","modified":1487137383000},{"_id":"themes/typing/layout/_partial/archive.ejs","hash":"9665ed77377c8eb15d94c04a33905d26704f2e13","modified":1487137383000},{"_id":"themes/typing/layout/_partial/archive-post.ejs","hash":"877b0b79538a63f1ae73407e372ee041f8b65e1b","modified":1487137383000},{"_id":"themes/typing/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1487137383000},{"_id":"themes/typing/layout/_partial/footer.ejs","hash":"22562748208c7413ec0ee76fa21697ab02051d85","modified":1487144211000},{"_id":"themes/typing/layout/_partial/article.ejs","hash":"a7b3a3c51f8b089c752f475c2cb393d3fa73c010","modified":1487137383000},{"_id":"themes/typing/layout/_partial/baidu_tongji.ejs","hash":"998936b5bf3fcef3b2de5e21fe24e956afa43f59","modified":1487137383000},{"_id":"themes/typing/layout/_partial/header.ejs","hash":"8f93e487e3dfd429f08a2aa6b414d0a87724ad7f","modified":1487137383000},{"_id":"themes/typing/layout/_partial/head.ejs","hash":"04133fd540fb4af025b57dcc9032c4b3db6058e4","modified":1487137383000},{"_id":"themes/typing/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1487137383000},{"_id":"themes/typing/.git/objects/pack/pack-dad82d03a4b8afd3651f44787da1da709ed1e5ca.idx","hash":"f5e83e07520e3d200be9ffc70543f00fce1a1703","modified":1487137382000},{"_id":"themes/typing/.git/refs/heads/master","hash":"a4871b79e5f42e19c6e32bbde03d5282b5696d35","modified":1487137383000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1487137383000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1487137383000},{"_id":"themes/typing/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1487137383000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1487137383000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1487137383000},{"_id":"themes/typing/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1487137383000},{"_id":"themes/typing/layout/_partial/post/date.ejs","hash":"38affd429d5ed376b349219f3094a7d530c58a70","modified":1487137383000},{"_id":"themes/typing/layout/_partial/post/category.ejs","hash":"6cd9c85b105db04a74678d0a6c5440e51d9d84f7","modified":1487137383000},{"_id":"themes/typing/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1487137383000},{"_id":"themes/typing/layout/_partial/post/nav.ejs","hash":"93e594128978c0e7310c9aef3e150effbf549f0e","modified":1487137383000},{"_id":"themes/typing/layout/_partial/post/tag.ejs","hash":"90209686eabc6c3e7a6a7ef2defd0b84611d9f41","modified":1487137383000},{"_id":"themes/typing/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1487137383000},{"_id":"themes/typing/.git/logs/refs/heads/master","hash":"d09f8ac067a5532e4047e645a128f4781d788131","modified":1487137383000},{"_id":"themes/typing/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1487137383000},{"_id":"themes/typing/.git/logs/refs/remotes/origin/HEAD","hash":"d09f8ac067a5532e4047e645a128f4781d788131","modified":1487137383000},{"_id":"themes/typing/.git/objects/pack/pack-dad82d03a4b8afd3651f44787da1da709ed1e5ca.pack","hash":"e0201930340aee5b91da5f389ac57521fb606a75","modified":1487137382000}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-02-15T09:42:51.000Z","_content":"\nAndroid Programmer,From Taizhou, China. Currently working in Shanghai.\n\n## Education\n\n* NIT(2012-2016)\n\n## likes\n\n* NBA,Basketball\n\n## Skills\n\n* **Skill** -  `Java` / `Android` \n    \n## Company\n\n* Siyanhui\n\n## Contact me\n\n[yuanda.wang1993@gmail.com](mailto:yuanda.wang1993@gmail.com)","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-02-15 17:42:51\n---\n\nAndroid Programmer,From Taizhou, China. Currently working in Shanghai.\n\n## Education\n\n* NIT(2012-2016)\n\n## likes\n\n* NBA,Basketball\n\n## Skills\n\n* **Skill** -  `Java` / `Android` \n    \n## Company\n\n* Siyanhui\n\n## Contact me\n\n[yuanda.wang1993@gmail.com](mailto:yuanda.wang1993@gmail.com)","updated":"2017-02-15T09:46:38.000Z","path":"about/index.html","_id":"ciz6rs6pb00011kgfni2zai53","comments":1,"layout":"page","content":"<p>Android Programmer,From Taizhou, China. Currently working in Shanghai.</p>\n<h2 id=\"Education\"><a href=\"#Education\" class=\"headerlink\" title=\"Education\"></a>Education</h2><ul>\n<li>NIT(2012-2016)</li>\n</ul>\n<h2 id=\"likes\"><a href=\"#likes\" class=\"headerlink\" title=\"likes\"></a>likes</h2><ul>\n<li>NBA,Basketball</li>\n</ul>\n<h2 id=\"Skills\"><a href=\"#Skills\" class=\"headerlink\" title=\"Skills\"></a>Skills</h2><ul>\n<li><strong>Skill</strong> -  <code>Java</code> / <code>Android</code> </li>\n</ul>\n<h2 id=\"Company\"><a href=\"#Company\" class=\"headerlink\" title=\"Company\"></a>Company</h2><ul>\n<li>Siyanhui</li>\n</ul>\n<h2 id=\"Contact-me\"><a href=\"#Contact-me\" class=\"headerlink\" title=\"Contact me\"></a>Contact me</h2><p><a href=\"mailto:yuanda.wang1993@gmail.com\" target=\"_blank\" rel=\"external\">yuanda.wang1993@gmail.com</a></p>\n","excerpt":"","more":"<p>Android Programmer,From Taizhou, China. Currently working in Shanghai.</p>\n<h2 id=\"Education\"><a href=\"#Education\" class=\"headerlink\" title=\"Education\"></a>Education</h2><ul>\n<li>NIT(2012-2016)</li>\n</ul>\n<h2 id=\"likes\"><a href=\"#likes\" class=\"headerlink\" title=\"likes\"></a>likes</h2><ul>\n<li>NBA,Basketball</li>\n</ul>\n<h2 id=\"Skills\"><a href=\"#Skills\" class=\"headerlink\" title=\"Skills\"></a>Skills</h2><ul>\n<li><strong>Skill</strong> -  <code>Java</code> / <code>Android</code> </li>\n</ul>\n<h2 id=\"Company\"><a href=\"#Company\" class=\"headerlink\" title=\"Company\"></a>Company</h2><ul>\n<li>Siyanhui</li>\n</ul>\n<h2 id=\"Contact-me\"><a href=\"#Contact-me\" class=\"headerlink\" title=\"Contact me\"></a>Contact me</h2><p><a href=\"mailto:yuanda.wang1993@gmail.com\">yuanda.wang1993@gmail.com</a></p>\n"}],"Post":[{"title":"Android事件分发机制","date":"2016-11-08T08:02:42.000Z","_content":"\n看了大神们的技术博客和安卓源码，总结如下\n-----\n\n1.在触摸任意一个控件的时候，都会先调用该控件的 dispatchTouchEvent() 方法。\n<pre><code>\n  /**\n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * @return True if the event was handled by the view, false otherwise.\n     */\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // If the event should be handled by accessibility focus first.\n        if (event.isTargetAccessibilityFocus()) {\n            // We don't have focus or no virtual descendant has it, do not handle the event.\n            if (!isAccessibilityFocusedViewOrHost()) {\n                return false;\n            }\n            // We have focus and got the event, then use normal event dispatch.\n            event.setTargetAccessibilityFocus(false);\n        }\n\n        boolean result = false;\n\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(event, 0);\n        }\n\n        final int actionMasked = event.getActionMasked();\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Defensive cleanup for new gesture\n            stopNestedScroll();\n        }\n\n        if (onFilterTouchEventForSecurity(event)) {\n            //noinspection SimplifiableIfStatement\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n            //可以从上面代码看出当以上条件都成立时，即也要满足当onTouch()返回true的时候，就不会执行onTouchEvent()方法了。\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        if (!result && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\n        }\n\n        // Clean up after nested scrolls if this is the end of a gesture;\n        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest\n        // of the gesture.\n        if (actionMasked == MotionEvent.ACTION_UP ||\n                actionMasked == MotionEvent.ACTION_CANCEL ||\n                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n            stopNestedScroll();\n        }\n\n        return result;\n    }\n<code></pre>\n\n2.onTouch在onTouchEvent之前执行，如果onTouch返回true将事件消费了,则onTouchEvent将不会执行。\n\n3.Android中事件传递按照从上到下进行层级传递，事件处理从Activity开始到ViewGroup再到View。。\n\n4.ViewGroup可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true表示不允许事件向子View传递，返回false代表不对事件进行拦截,默认返回false.\n\n5.在onTouchEvent中主要处理\n\npress ：按下时候View状态的改变，比如View的背景的drawable会变成press 状态\n\nclick/tap： 快速点击\n\nlongClick：长按\n\nfocus：跟press类似，也是View状态的改变\n\ntouchDelegate：分发这个点击事件给其他的View，这个点击事件传到其他View前会改变这个事件的点击坐标，如果在指定的Rect里面，则是View的中点坐标，否则在View之外\n\n6.onTouch事件要先于onClick事件执行，onTouch在事件分发方法dispatchTouchEvent中调用，而onClick在事件处理方法onTouchEvent中被调用，onTouchEvent要后于dispatchTouchEvent方法的调用。\n\n7.事件传递方法包括dispatchTouchEvent、onTouchEvent、onInterceptTouchEvent，其中前两个是View和ViewGroup都有的，最后一个是只有ViewGroup才有的方法。这三个方法的作用分别是负责事件分发、事件处理、事件拦截。\n","source":"_posts/Android事件分发机制.md","raw":"---\ntitle: Android事件分发机制\ndate: 2016-11-08 16:02:42\ntags:\n---\n\n看了大神们的技术博客和安卓源码，总结如下\n-----\n\n1.在触摸任意一个控件的时候，都会先调用该控件的 dispatchTouchEvent() 方法。\n<pre><code>\n  /**\n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * @return True if the event was handled by the view, false otherwise.\n     */\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // If the event should be handled by accessibility focus first.\n        if (event.isTargetAccessibilityFocus()) {\n            // We don't have focus or no virtual descendant has it, do not handle the event.\n            if (!isAccessibilityFocusedViewOrHost()) {\n                return false;\n            }\n            // We have focus and got the event, then use normal event dispatch.\n            event.setTargetAccessibilityFocus(false);\n        }\n\n        boolean result = false;\n\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(event, 0);\n        }\n\n        final int actionMasked = event.getActionMasked();\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Defensive cleanup for new gesture\n            stopNestedScroll();\n        }\n\n        if (onFilterTouchEventForSecurity(event)) {\n            //noinspection SimplifiableIfStatement\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n            //可以从上面代码看出当以上条件都成立时，即也要满足当onTouch()返回true的时候，就不会执行onTouchEvent()方法了。\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        if (!result && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\n        }\n\n        // Clean up after nested scrolls if this is the end of a gesture;\n        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest\n        // of the gesture.\n        if (actionMasked == MotionEvent.ACTION_UP ||\n                actionMasked == MotionEvent.ACTION_CANCEL ||\n                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n            stopNestedScroll();\n        }\n\n        return result;\n    }\n<code></pre>\n\n2.onTouch在onTouchEvent之前执行，如果onTouch返回true将事件消费了,则onTouchEvent将不会执行。\n\n3.Android中事件传递按照从上到下进行层级传递，事件处理从Activity开始到ViewGroup再到View。。\n\n4.ViewGroup可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true表示不允许事件向子View传递，返回false代表不对事件进行拦截,默认返回false.\n\n5.在onTouchEvent中主要处理\n\npress ：按下时候View状态的改变，比如View的背景的drawable会变成press 状态\n\nclick/tap： 快速点击\n\nlongClick：长按\n\nfocus：跟press类似，也是View状态的改变\n\ntouchDelegate：分发这个点击事件给其他的View，这个点击事件传到其他View前会改变这个事件的点击坐标，如果在指定的Rect里面，则是View的中点坐标，否则在View之外\n\n6.onTouch事件要先于onClick事件执行，onTouch在事件分发方法dispatchTouchEvent中调用，而onClick在事件处理方法onTouchEvent中被调用，onTouchEvent要后于dispatchTouchEvent方法的调用。\n\n7.事件传递方法包括dispatchTouchEvent、onTouchEvent、onInterceptTouchEvent，其中前两个是View和ViewGroup都有的，最后一个是只有ViewGroup才有的方法。这三个方法的作用分别是负责事件分发、事件处理、事件拦截。\n","slug":"Android事件分发机制","published":1,"updated":"2017-02-15T08:03:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6p400001kgf7absihtp","content":"<h2 id=\"看了大神们的技术博客和安卓源码，总结如下\"><a href=\"#看了大神们的技术博客和安卓源码，总结如下\" class=\"headerlink\" title=\"看了大神们的技术博客和安卓源码，总结如下\"></a>看了大神们的技术博客和安卓源码，总结如下</h2><p>1.在触摸任意一个控件的时候，都会先调用该控件的 dispatchTouchEvent() 方法。</p>\n<pre><code>\n  /**\n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * @return True if the event was handled by the view, false otherwise.\n     */\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // If the event should be handled by accessibility focus first.\n        if (event.isTargetAccessibilityFocus()) {\n            // We don't have focus or no virtual descendant has it, do not handle the event.\n            if (!isAccessibilityFocusedViewOrHost()) {\n                return false;\n            }\n            // We have focus and got the event, then use normal event dispatch.\n            event.setTargetAccessibilityFocus(false);\n        }\n\n        boolean result = false;\n\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(event, 0);\n        }\n\n        final int actionMasked = event.getActionMasked();\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Defensive cleanup for new gesture\n            stopNestedScroll();\n        }\n\n        if (onFilterTouchEventForSecurity(event)) {\n            //noinspection SimplifiableIfStatement\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n            //可以从上面代码看出当以上条件都成立时，即也要满足当onTouch()返回true的时候，就不会执行onTouchEvent()方法了。\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        if (!result && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\n        }\n\n        // Clean up after nested scrolls if this is the end of a gesture;\n        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest\n        // of the gesture.\n        if (actionMasked == MotionEvent.ACTION_UP ||\n                actionMasked == MotionEvent.ACTION_CANCEL ||\n                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n            stopNestedScroll();\n        }\n\n        return result;\n    }\n<code></code></code></pre>\n\n<p>2.onTouch在onTouchEvent之前执行，如果onTouch返回true将事件消费了,则onTouchEvent将不会执行。</p>\n<p>3.Android中事件传递按照从上到下进行层级传递，事件处理从Activity开始到ViewGroup再到View。。</p>\n<p>4.ViewGroup可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true表示不允许事件向子View传递，返回false代表不对事件进行拦截,默认返回false.</p>\n<p>5.在onTouchEvent中主要处理</p>\n<p>press ：按下时候View状态的改变，比如View的背景的drawable会变成press 状态</p>\n<p>click/tap： 快速点击</p>\n<p>longClick：长按</p>\n<p>focus：跟press类似，也是View状态的改变</p>\n<p>touchDelegate：分发这个点击事件给其他的View，这个点击事件传到其他View前会改变这个事件的点击坐标，如果在指定的Rect里面，则是View的中点坐标，否则在View之外</p>\n<p>6.onTouch事件要先于onClick事件执行，onTouch在事件分发方法dispatchTouchEvent中调用，而onClick在事件处理方法onTouchEvent中被调用，onTouchEvent要后于dispatchTouchEvent方法的调用。</p>\n<p>7.事件传递方法包括dispatchTouchEvent、onTouchEvent、onInterceptTouchEvent，其中前两个是View和ViewGroup都有的，最后一个是只有ViewGroup才有的方法。这三个方法的作用分别是负责事件分发、事件处理、事件拦截。</p>\n","excerpt":"","more":"<h2 id=\"看了大神们的技术博客和安卓源码，总结如下\"><a href=\"#看了大神们的技术博客和安卓源码，总结如下\" class=\"headerlink\" title=\"看了大神们的技术博客和安卓源码，总结如下\"></a>看了大神们的技术博客和安卓源码，总结如下</h2><p>1.在触摸任意一个控件的时候，都会先调用该控件的 dispatchTouchEvent() 方法。</p>\n<pre><code>\n  /**\n     * Pass the touch screen motion event down to the target view, or this\n     * view if it is the target.\n     *\n     * @param event The motion event to be dispatched.\n     * @return True if the event was handled by the view, false otherwise.\n     */\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        // If the event should be handled by accessibility focus first.\n        if (event.isTargetAccessibilityFocus()) {\n            // We don't have focus or no virtual descendant has it, do not handle the event.\n            if (!isAccessibilityFocusedViewOrHost()) {\n                return false;\n            }\n            // We have focus and got the event, then use normal event dispatch.\n            event.setTargetAccessibilityFocus(false);\n        }\n\n        boolean result = false;\n\n        if (mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onTouchEvent(event, 0);\n        }\n\n        final int actionMasked = event.getActionMasked();\n        if (actionMasked == MotionEvent.ACTION_DOWN) {\n            // Defensive cleanup for new gesture\n            stopNestedScroll();\n        }\n\n        if (onFilterTouchEventForSecurity(event)) {\n            //noinspection SimplifiableIfStatement\n            ListenerInfo li = mListenerInfo;\n            if (li != null && li.mOnTouchListener != null\n                    && (mViewFlags & ENABLED_MASK) == ENABLED\n                    && li.mOnTouchListener.onTouch(this, event)) {\n                result = true;\n            }\n            //可以从上面代码看出当以上条件都成立时，即也要满足当onTouch()返回true的时候，就不会执行onTouchEvent()方法了。\n            if (!result && onTouchEvent(event)) {\n                result = true;\n            }\n        }\n\n        if (!result && mInputEventConsistencyVerifier != null) {\n            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\n        }\n\n        // Clean up after nested scrolls if this is the end of a gesture;\n        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest\n        // of the gesture.\n        if (actionMasked == MotionEvent.ACTION_UP ||\n                actionMasked == MotionEvent.ACTION_CANCEL ||\n                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\n            stopNestedScroll();\n        }\n\n        return result;\n    }\n<code></pre>\n\n<p>2.onTouch在onTouchEvent之前执行，如果onTouch返回true将事件消费了,则onTouchEvent将不会执行。</p>\n<p>3.Android中事件传递按照从上到下进行层级传递，事件处理从Activity开始到ViewGroup再到View。。</p>\n<p>4.ViewGroup可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true表示不允许事件向子View传递，返回false代表不对事件进行拦截,默认返回false.</p>\n<p>5.在onTouchEvent中主要处理</p>\n<p>press ：按下时候View状态的改变，比如View的背景的drawable会变成press 状态</p>\n<p>click/tap： 快速点击</p>\n<p>longClick：长按</p>\n<p>focus：跟press类似，也是View状态的改变</p>\n<p>touchDelegate：分发这个点击事件给其他的View，这个点击事件传到其他View前会改变这个事件的点击坐标，如果在指定的Rect里面，则是View的中点坐标，否则在View之外</p>\n<p>6.onTouch事件要先于onClick事件执行，onTouch在事件分发方法dispatchTouchEvent中调用，而onClick在事件处理方法onTouchEvent中被调用，onTouchEvent要后于dispatchTouchEvent方法的调用。</p>\n<p>7.事件传递方法包括dispatchTouchEvent、onTouchEvent、onInterceptTouchEvent，其中前两个是View和ViewGroup都有的，最后一个是只有ViewGroup才有的方法。这三个方法的作用分别是负责事件分发、事件处理、事件拦截。</p>\n"},{"title":"SDK开发学习小结","date":"2017-01-18T08:08:39.000Z","_content":"以下为做表情云SDK开发时的一些小结\n \n\n- 什么是SDK?\n\n  SDK(SoftWare Development Kit)软件开发工具包。通常为辅助某软件而编写的特定软件包，框架集合等，一般包含相关文档，范例及工具。\n\n  SDK主要包含Framework,API及Library这三部分。\n\n  Framework定义了SDK整体的可重用设计，规定了SDK各功能模块的职责及依赖关系。\n\n  各个功能模块体现为Library。\n\n  API则是进行模块间内部通信和SDK对外提供服务的接口。\n\n- SDK整体架构设计\n\n  a.模块化开发\n\n  b.组件化开发\n\n  c.插件化开发\n\n\n- SDK需实现的目标\n\n  a.简洁易用\n\n  b.稳定\n\n  c.轻量\n\n  d.高效\n\n- API设计\n\n  a.方法名能表明用途\n\n  b.方法要明确其单一功能\n\n  c.方法异常问题\n\n  d.方法权限控制\n\n  e.参数合法性校验\n\n  f.避免参数过长\n\n  g.避免直接返回NULL\n\n  h.谨慎使用方法重载\n\n  ​","source":"_posts/SDK开发学习小结.md","raw":"---\ntitle: SDK开发学习小结\ndate: 2017-01-18 16:08:39\ntags:\n---\n以下为做表情云SDK开发时的一些小结\n \n\n- 什么是SDK?\n\n  SDK(SoftWare Development Kit)软件开发工具包。通常为辅助某软件而编写的特定软件包，框架集合等，一般包含相关文档，范例及工具。\n\n  SDK主要包含Framework,API及Library这三部分。\n\n  Framework定义了SDK整体的可重用设计，规定了SDK各功能模块的职责及依赖关系。\n\n  各个功能模块体现为Library。\n\n  API则是进行模块间内部通信和SDK对外提供服务的接口。\n\n- SDK整体架构设计\n\n  a.模块化开发\n\n  b.组件化开发\n\n  c.插件化开发\n\n\n- SDK需实现的目标\n\n  a.简洁易用\n\n  b.稳定\n\n  c.轻量\n\n  d.高效\n\n- API设计\n\n  a.方法名能表明用途\n\n  b.方法要明确其单一功能\n\n  c.方法异常问题\n\n  d.方法权限控制\n\n  e.参数合法性校验\n\n  f.避免参数过长\n\n  g.避免直接返回NULL\n\n  h.谨慎使用方法重载\n\n  ​","slug":"SDK开发学习小结","published":1,"updated":"2017-02-15T08:09:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6pd00021kgfoz3hgxlv","content":"<p>以下为做表情云SDK开发时的一些小结</p>\n<ul>\n<li><p>什么是SDK?</p>\n<p>SDK(SoftWare Development Kit)软件开发工具包。通常为辅助某软件而编写的特定软件包，框架集合等，一般包含相关文档，范例及工具。</p>\n<p>SDK主要包含Framework,API及Library这三部分。</p>\n<p>Framework定义了SDK整体的可重用设计，规定了SDK各功能模块的职责及依赖关系。</p>\n<p>各个功能模块体现为Library。</p>\n<p>API则是进行模块间内部通信和SDK对外提供服务的接口。</p>\n</li>\n<li><p>SDK整体架构设计</p>\n<p>a.模块化开发</p>\n<p>b.组件化开发</p>\n<p>c.插件化开发</p>\n</li>\n</ul>\n<ul>\n<li><p>SDK需实现的目标</p>\n<p>a.简洁易用</p>\n<p>b.稳定</p>\n<p>c.轻量</p>\n<p>d.高效</p>\n</li>\n<li><p>API设计</p>\n<p>a.方法名能表明用途</p>\n<p>b.方法要明确其单一功能</p>\n<p>c.方法异常问题</p>\n<p>d.方法权限控制</p>\n<p>e.参数合法性校验</p>\n<p>f.避免参数过长</p>\n<p>g.避免直接返回NULL</p>\n<p>h.谨慎使用方法重载</p>\n<p>​</p>\n</li>\n</ul>\n","excerpt":"","more":"<p>以下为做表情云SDK开发时的一些小结</p>\n<ul>\n<li><p>什么是SDK?</p>\n<p>SDK(SoftWare Development Kit)软件开发工具包。通常为辅助某软件而编写的特定软件包，框架集合等，一般包含相关文档，范例及工具。</p>\n<p>SDK主要包含Framework,API及Library这三部分。</p>\n<p>Framework定义了SDK整体的可重用设计，规定了SDK各功能模块的职责及依赖关系。</p>\n<p>各个功能模块体现为Library。</p>\n<p>API则是进行模块间内部通信和SDK对外提供服务的接口。</p>\n</li>\n<li><p>SDK整体架构设计</p>\n<p>a.模块化开发</p>\n<p>b.组件化开发</p>\n<p>c.插件化开发</p>\n</li>\n</ul>\n<ul>\n<li><p>SDK需实现的目标</p>\n<p>a.简洁易用</p>\n<p>b.稳定</p>\n<p>c.轻量</p>\n<p>d.高效</p>\n</li>\n<li><p>API设计</p>\n<p>a.方法名能表明用途</p>\n<p>b.方法要明确其单一功能</p>\n<p>c.方法异常问题</p>\n<p>d.方法权限控制</p>\n<p>e.参数合法性校验</p>\n<p>f.避免参数过长</p>\n<p>g.避免直接返回NULL</p>\n<p>h.谨慎使用方法重载</p>\n<p>​</p>\n</li>\n</ul>\n"},{"title":"Android-Gradle","date":"2016-10-17T07:54:36.000Z","_content":"Android build.gradle笔记\n\n<pre><code>\napply plugin: 'com.android.application'\n \nandroid {\n    /**\n     * 设置编译 sdk 和编译工具的版本\n     */\n    compileSdkVersion 24\n    buildToolsVersion \"24.0.3\"\n \n    /**\n     * 关于签名, 请参考 google 官方文档 Sign Your App: https://developer.android.com/studio/publish/app-signing.html#debug-mode\n     */\n    signingConfigs {\n        /**\n         * As 会自动帮我们使用 debug certificate 进行签名. 这个 debug certificate 每次安装 As 都会变,\n         * 因此不适合作为发布之用.\n         */\n        debug {\n        }\n \n        /**\n         * 由于 Module-level Build Script(本文件) 也要放在 VCS 中管理, 所以不将密码等信息写在这里.\n         * 一般的做法是: 在本机设置环境变量, 然后通过下面代码中演示的这种方式读取.\n         * 当然, 最佳实践也指导我们将 `gradle.properties` 排除在 VCS 之外,\n         * 此时, 也在该文件中将密码设置为变量, 然后在此读取使用.\n         */\n        release {\n            storeFile file(\"$System.env.STORE_FILE\")\n            storePassword \"$System.env.STORE_PASSWORD\"\n            keyAlias \"$System.env.KEY_ALIAS\"\n            keyPassword \"$System.env.KEY_PASSWORD\"\n        }\n    }\n \n    /**\n     * 为所有的 build variants 设置默认的值. 关于 build variant, 我们后面会用一张图片说明\n     */\n    defaultConfig {\n        applicationId \"com.walfud.myapplication\"\n        minSdkVersion 23\n        targetSdkVersion 24\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n \n    /**\n     * type 默认会有 debug 和 release. 不管你写不写都如此.\n     * 通常, 我们在 debug 中保留默认值, release 中开启混淆, 并使用私有的签名\n     */\n    buildTypes {\n        debug {\n            // 使用默认值\n        }\n \n        release {\n            // 混淆\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n \n            // 签名\n            signingConfig signingConfigs.release\n        }\n    }\n \n    /**\n     * flavor 强调的是不同的版本, 比如付费版和免费版.\n     * 在国内, 这个字段更多被用于区分不同的渠道, 即 360 渠道, 小米渠道等等.\n     */\n    productFlavors {\n        m360 {}\n        xiaomi {}\n    }\n \n    /**\n     * 这个选项基本不用.\n     * lt;a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits\"gt;官方说lt;/agt;: 使用 splits 可以比使用 flavor 更加有效创建多 apk.\n     * 目前而言, 仅支持 Density 和 ABIs 这两个分类.\n     */\n    splits {\n        // 按屏幕尺寸\n        density {\n            enable true\n \n            // 默认包含全部分辨率, 这里是剔除一些我们不要的\n            exclude \"ldpi\", \"mdpi\", \"xxxhdpi\", \"400dpi\", \"560dpi\", \"tvdpi\"\n        }\n \n        // 按架构\n        abi {\n            enable true\n \n            // 使用 `reset()` 后, 我们就相当于不包含任何架构,\n            // 这种情况下我们就可以通过 `include` 指定想要使用的架构\n            reset()\n \n            include 'x86', 'armeabi-v7a'\n            universalApk true       // 是否同时生成一个包含全部 Architecture 的包\n        }\n    }\n}\n \n/**\n * 这个项目的依赖\n */\ndependencies {\n    /**\n     * `fileTree` 导入 libs 目录下的所有 jar 文件\n     */\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n \n    /**\n     * 想导入本地 aar, 首先需要指明本地 aar 的位置, 如下 `repositories` 中所示, 我们把 aar 放在了\n     * Module-level 的 libs 目录下. 然后引用这个文件即可.\n     */\n    compile(name: 'components', ext: 'aar')\n}\n \n/**\n * 配置了去哪里查找这个模块依赖文件\n */\nrepositories {\n    flatDir {\n        dirs 'libs'\n    }\n}\n</code></pre>\n","source":"_posts/Android-Gradle.md","raw":"---\ntitle: Android-Gradle\ndate: 2016-10-17 15:54:36\ntags:\n---\nAndroid build.gradle笔记\n\n<pre><code>\napply plugin: 'com.android.application'\n \nandroid {\n    /**\n     * 设置编译 sdk 和编译工具的版本\n     */\n    compileSdkVersion 24\n    buildToolsVersion \"24.0.3\"\n \n    /**\n     * 关于签名, 请参考 google 官方文档 Sign Your App: https://developer.android.com/studio/publish/app-signing.html#debug-mode\n     */\n    signingConfigs {\n        /**\n         * As 会自动帮我们使用 debug certificate 进行签名. 这个 debug certificate 每次安装 As 都会变,\n         * 因此不适合作为发布之用.\n         */\n        debug {\n        }\n \n        /**\n         * 由于 Module-level Build Script(本文件) 也要放在 VCS 中管理, 所以不将密码等信息写在这里.\n         * 一般的做法是: 在本机设置环境变量, 然后通过下面代码中演示的这种方式读取.\n         * 当然, 最佳实践也指导我们将 `gradle.properties` 排除在 VCS 之外,\n         * 此时, 也在该文件中将密码设置为变量, 然后在此读取使用.\n         */\n        release {\n            storeFile file(\"$System.env.STORE_FILE\")\n            storePassword \"$System.env.STORE_PASSWORD\"\n            keyAlias \"$System.env.KEY_ALIAS\"\n            keyPassword \"$System.env.KEY_PASSWORD\"\n        }\n    }\n \n    /**\n     * 为所有的 build variants 设置默认的值. 关于 build variant, 我们后面会用一张图片说明\n     */\n    defaultConfig {\n        applicationId \"com.walfud.myapplication\"\n        minSdkVersion 23\n        targetSdkVersion 24\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n \n    /**\n     * type 默认会有 debug 和 release. 不管你写不写都如此.\n     * 通常, 我们在 debug 中保留默认值, release 中开启混淆, 并使用私有的签名\n     */\n    buildTypes {\n        debug {\n            // 使用默认值\n        }\n \n        release {\n            // 混淆\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n \n            // 签名\n            signingConfig signingConfigs.release\n        }\n    }\n \n    /**\n     * flavor 强调的是不同的版本, 比如付费版和免费版.\n     * 在国内, 这个字段更多被用于区分不同的渠道, 即 360 渠道, 小米渠道等等.\n     */\n    productFlavors {\n        m360 {}\n        xiaomi {}\n    }\n \n    /**\n     * 这个选项基本不用.\n     * lt;a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits\"gt;官方说lt;/agt;: 使用 splits 可以比使用 flavor 更加有效创建多 apk.\n     * 目前而言, 仅支持 Density 和 ABIs 这两个分类.\n     */\n    splits {\n        // 按屏幕尺寸\n        density {\n            enable true\n \n            // 默认包含全部分辨率, 这里是剔除一些我们不要的\n            exclude \"ldpi\", \"mdpi\", \"xxxhdpi\", \"400dpi\", \"560dpi\", \"tvdpi\"\n        }\n \n        // 按架构\n        abi {\n            enable true\n \n            // 使用 `reset()` 后, 我们就相当于不包含任何架构,\n            // 这种情况下我们就可以通过 `include` 指定想要使用的架构\n            reset()\n \n            include 'x86', 'armeabi-v7a'\n            universalApk true       // 是否同时生成一个包含全部 Architecture 的包\n        }\n    }\n}\n \n/**\n * 这个项目的依赖\n */\ndependencies {\n    /**\n     * `fileTree` 导入 libs 目录下的所有 jar 文件\n     */\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n \n    /**\n     * 想导入本地 aar, 首先需要指明本地 aar 的位置, 如下 `repositories` 中所示, 我们把 aar 放在了\n     * Module-level 的 libs 目录下. 然后引用这个文件即可.\n     */\n    compile(name: 'components', ext: 'aar')\n}\n \n/**\n * 配置了去哪里查找这个模块依赖文件\n */\nrepositories {\n    flatDir {\n        dirs 'libs'\n    }\n}\n</code></pre>\n","slug":"Android-Gradle","published":1,"updated":"2017-02-15T07:55:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6ph00031kgfl67qlr8v","content":"<p>Android build.gradle笔记</p>\n<pre><code>\napply plugin: 'com.android.application'\n\nandroid {\n    /**\n     * 设置编译 sdk 和编译工具的版本\n     */\n    compileSdkVersion 24\n    buildToolsVersion \"24.0.3\"\n\n    /**\n     * 关于签名, 请参考 google 官方文档 Sign Your App: https://developer.android.com/studio/publish/app-signing.html#debug-mode\n     */\n    signingConfigs {\n        /**\n         * As 会自动帮我们使用 debug certificate 进行签名. 这个 debug certificate 每次安装 As 都会变,\n         * 因此不适合作为发布之用.\n         */\n        debug {\n        }\n\n        /**\n         * 由于 Module-level Build Script(本文件) 也要放在 VCS 中管理, 所以不将密码等信息写在这里.\n         * 一般的做法是: 在本机设置环境变量, 然后通过下面代码中演示的这种方式读取.\n         * 当然, 最佳实践也指导我们将 `gradle.properties` 排除在 VCS 之外,\n         * 此时, 也在该文件中将密码设置为变量, 然后在此读取使用.\n         */\n        release {\n            storeFile file(\"$System.env.STORE_FILE\")\n            storePassword \"$System.env.STORE_PASSWORD\"\n            keyAlias \"$System.env.KEY_ALIAS\"\n            keyPassword \"$System.env.KEY_PASSWORD\"\n        }\n    }\n\n    /**\n     * 为所有的 build variants 设置默认的值. 关于 build variant, 我们后面会用一张图片说明\n     */\n    defaultConfig {\n        applicationId \"com.walfud.myapplication\"\n        minSdkVersion 23\n        targetSdkVersion 24\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n\n    /**\n     * type 默认会有 debug 和 release. 不管你写不写都如此.\n     * 通常, 我们在 debug 中保留默认值, release 中开启混淆, 并使用私有的签名\n     */\n    buildTypes {\n        debug {\n            // 使用默认值\n        }\n\n        release {\n            // 混淆\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\n            // 签名\n            signingConfig signingConfigs.release\n        }\n    }\n\n    /**\n     * flavor 强调的是不同的版本, 比如付费版和免费版.\n     * 在国内, 这个字段更多被用于区分不同的渠道, 即 360 渠道, 小米渠道等等.\n     */\n    productFlavors {\n        m360 {}\n        xiaomi {}\n    }\n\n    /**\n     * 这个选项基本不用.\n     * lt;a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits\"gt;官方说lt;/agt;: 使用 splits 可以比使用 flavor 更加有效创建多 apk.\n     * 目前而言, 仅支持 Density 和 ABIs 这两个分类.\n     */\n    splits {\n        // 按屏幕尺寸\n        density {\n            enable true\n\n            // 默认包含全部分辨率, 这里是剔除一些我们不要的\n            exclude \"ldpi\", \"mdpi\", \"xxxhdpi\", \"400dpi\", \"560dpi\", \"tvdpi\"\n        }\n\n        // 按架构\n        abi {\n            enable true\n\n            // 使用 `reset()` 后, 我们就相当于不包含任何架构,\n            // 这种情况下我们就可以通过 `include` 指定想要使用的架构\n            reset()\n\n            include 'x86', 'armeabi-v7a'\n            universalApk true       // 是否同时生成一个包含全部 Architecture 的包\n        }\n    }\n}\n\n/**\n * 这个项目的依赖\n */\ndependencies {\n    /**\n     * `fileTree` 导入 libs 目录下的所有 jar 文件\n     */\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n\n    /**\n     * 想导入本地 aar, 首先需要指明本地 aar 的位置, 如下 `repositories` 中所示, 我们把 aar 放在了\n     * Module-level 的 libs 目录下. 然后引用这个文件即可.\n     */\n    compile(name: 'components', ext: 'aar')\n}\n\n/**\n * 配置了去哪里查找这个模块依赖文件\n */\nrepositories {\n    flatDir {\n        dirs 'libs'\n    }\n}\n</code></pre>\n","excerpt":"","more":"<p>Android build.gradle笔记</p>\n<pre><code>\napply plugin: 'com.android.application'\n\nandroid {\n    /**\n     * 设置编译 sdk 和编译工具的版本\n     */\n    compileSdkVersion 24\n    buildToolsVersion \"24.0.3\"\n\n    /**\n     * 关于签名, 请参考 google 官方文档 Sign Your App: https://developer.android.com/studio/publish/app-signing.html#debug-mode\n     */\n    signingConfigs {\n        /**\n         * As 会自动帮我们使用 debug certificate 进行签名. 这个 debug certificate 每次安装 As 都会变,\n         * 因此不适合作为发布之用.\n         */\n        debug {\n        }\n\n        /**\n         * 由于 Module-level Build Script(本文件) 也要放在 VCS 中管理, 所以不将密码等信息写在这里.\n         * 一般的做法是: 在本机设置环境变量, 然后通过下面代码中演示的这种方式读取.\n         * 当然, 最佳实践也指导我们将 `gradle.properties` 排除在 VCS 之外,\n         * 此时, 也在该文件中将密码设置为变量, 然后在此读取使用.\n         */\n        release {\n            storeFile file(\"$System.env.STORE_FILE\")\n            storePassword \"$System.env.STORE_PASSWORD\"\n            keyAlias \"$System.env.KEY_ALIAS\"\n            keyPassword \"$System.env.KEY_PASSWORD\"\n        }\n    }\n\n    /**\n     * 为所有的 build variants 设置默认的值. 关于 build variant, 我们后面会用一张图片说明\n     */\n    defaultConfig {\n        applicationId \"com.walfud.myapplication\"\n        minSdkVersion 23\n        targetSdkVersion 24\n        versionCode 1\n        versionName \"1.0\"\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n\n    /**\n     * type 默认会有 debug 和 release. 不管你写不写都如此.\n     * 通常, 我们在 debug 中保留默认值, release 中开启混淆, 并使用私有的签名\n     */\n    buildTypes {\n        debug {\n            // 使用默认值\n        }\n\n        release {\n            // 混淆\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n\n            // 签名\n            signingConfig signingConfigs.release\n        }\n    }\n\n    /**\n     * flavor 强调的是不同的版本, 比如付费版和免费版.\n     * 在国内, 这个字段更多被用于区分不同的渠道, 即 360 渠道, 小米渠道等等.\n     */\n    productFlavors {\n        m360 {}\n        xiaomi {}\n    }\n\n    /**\n     * 这个选项基本不用.\n     * lt;a href=\"http://tools.android.com/tech-docs/new-build-system/user-guide/apk-splits\"gt;官方说lt;/agt;: 使用 splits 可以比使用 flavor 更加有效创建多 apk.\n     * 目前而言, 仅支持 Density 和 ABIs 这两个分类.\n     */\n    splits {\n        // 按屏幕尺寸\n        density {\n            enable true\n\n            // 默认包含全部分辨率, 这里是剔除一些我们不要的\n            exclude \"ldpi\", \"mdpi\", \"xxxhdpi\", \"400dpi\", \"560dpi\", \"tvdpi\"\n        }\n\n        // 按架构\n        abi {\n            enable true\n\n            // 使用 `reset()` 后, 我们就相当于不包含任何架构,\n            // 这种情况下我们就可以通过 `include` 指定想要使用的架构\n            reset()\n\n            include 'x86', 'armeabi-v7a'\n            universalApk true       // 是否同时生成一个包含全部 Architecture 的包\n        }\n    }\n}\n\n/**\n * 这个项目的依赖\n */\ndependencies {\n    /**\n     * `fileTree` 导入 libs 目录下的所有 jar 文件\n     */\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n\n    /**\n     * 想导入本地 aar, 首先需要指明本地 aar 的位置, 如下 `repositories` 中所示, 我们把 aar 放在了\n     * Module-level 的 libs 目录下. 然后引用这个文件即可.\n     */\n    compile(name: 'components', ext: 'aar')\n}\n\n/**\n * 配置了去哪里查找这个模块依赖文件\n */\nrepositories {\n    flatDir {\n        dirs 'libs'\n    }\n}\n</code></pre>\n"},{"title":"canvas","date":"2016-10-11T07:52:11.000Z","_content":"\nCanvas有关知识笔记\n\n## Save   Restore \n-----\n\n一般在重写view的onDraw方法时，onDraw方法里一般会传入一个Canvas对象，是用来绘制控件的画布。\n\n关于save和restore方法\n\nsave 用来保存canvas的状态。save后可以对canvas进行旋转，缩放，平移等。\n\nrestore用来恢复canvas之前保存的状态。防止save后对canvas的操作对后续产生影响。\n\nsave函数会返回一个saveCount,我们可以用restoreToCount方法来还原哪一个保存操作。","source":"_posts/canvas.md","raw":"---\ntitle: canvas\ndate: 2016-10-11 15:52:11\ntags:\n---\n\nCanvas有关知识笔记\n\n## Save   Restore \n-----\n\n一般在重写view的onDraw方法时，onDraw方法里一般会传入一个Canvas对象，是用来绘制控件的画布。\n\n关于save和restore方法\n\nsave 用来保存canvas的状态。save后可以对canvas进行旋转，缩放，平移等。\n\nrestore用来恢复canvas之前保存的状态。防止save后对canvas的操作对后续产生影响。\n\nsave函数会返回一个saveCount,我们可以用restoreToCount方法来还原哪一个保存操作。","slug":"canvas","published":1,"updated":"2017-02-15T07:53:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6pj00041kgfqmp95q4d","content":"<p>Canvas有关知识笔记</p>\n<h2 id=\"Save-Restore\"><a href=\"#Save-Restore\" class=\"headerlink\" title=\"Save   Restore\"></a>Save   Restore</h2><hr>\n<p>一般在重写view的onDraw方法时，onDraw方法里一般会传入一个Canvas对象，是用来绘制控件的画布。</p>\n<p>关于save和restore方法</p>\n<p>save 用来保存canvas的状态。save后可以对canvas进行旋转，缩放，平移等。</p>\n<p>restore用来恢复canvas之前保存的状态。防止save后对canvas的操作对后续产生影响。</p>\n<p>save函数会返回一个saveCount,我们可以用restoreToCount方法来还原哪一个保存操作。</p>\n","excerpt":"","more":"<p>Canvas有关知识笔记</p>\n<h2 id=\"Save-Restore\"><a href=\"#Save-Restore\" class=\"headerlink\" title=\"Save   Restore\"></a>Save   Restore</h2><hr>\n<p>一般在重写view的onDraw方法时，onDraw方法里一般会传入一个Canvas对象，是用来绘制控件的画布。</p>\n<p>关于save和restore方法</p>\n<p>save 用来保存canvas的状态。save后可以对canvas进行旋转，缩放，平移等。</p>\n<p>restore用来恢复canvas之前保存的状态。防止save后对canvas的操作对后续产生影响。</p>\n<p>save函数会返回一个saveCount,我们可以用restoreToCount方法来还原哪一个保存操作。</p>\n"},{"title":"git常用命令行","date":"2016-10-25T07:59:54.000Z","_content":"### 1.修改.gitignore为全局的方法\n\n直接修改.gitconfig内容，加上\n[core]excludesfile = /Users/你的账户文件夹/.gitignore_global\n\n### 2.如何编辑mac系统中的全局gitignore文件？\n\n在根目录下vim .gitignore_global\n\n### 3.配置语法：\n\n以斜杠“/”开头表示目录；\n\n以星号“*”通配多个字符；\n\n以问号“?”通配单个字符；\n\n以方括号“[]”包含单个字符的匹配列表；\n\n以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n\n此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效。\n\n\n---\n最常用的\n\n之前一直使用sourcetree来提交代码，现在准备改用命令行来提交。\n\n按照之前sourcetree的逻辑，推送代码前先提交代码到本地git仓库，然后拉取代码，再合并代码。最后推送到远程服务器上。\n\n添加代码对应git add\n\n提交代码对应git commit -m '提交说明'\n\n拉取代码对应git pull\n\n推送代码对应git push\n\n查看当前未提交代码  git status\n\n---\n补充\n\n---\n初始化配置\n\n<pre><code>\n#配置使用git仓库的人员姓名  \ngit config --global user.name \"Your Name Comes Here\"  \n  \n#配置使用git仓库的人员email  \ngit config --global user.email you@yourdomain.example.com  \n</code></pre>\n\n\n---\n取得Git仓库\n\n<pre><code>\n#初始化一个版本仓库  \ngit init  \n  \n#Clone远程版本库  \ngit clone git@github.com:darrenfantasy/darrenfantasy.github.io.git \n  \n#添加远程版本库origin，语法为 git remote add [shortname] [url]  \ngit remote add origin git@github.com:darrenfantasy/darrenfantasy.github.io.git  \n  \n#查看远程仓库  \ngit remote -v  \n</code></pre>\n\n---\n提交你的修改\n\n<pre><code>\n#添加当前修改的文件到暂存区  \ngit add .  \n  \n#如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件  \ngit add -u  \n  \n#提交你的修改  \ngit commit –m \"你的注释\"  \n  \n#推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支]  \ngit push origin master  \n  \n#查看文件状态  \ngit status  \n  \n#跟踪新文件  \ngit add readme.txt  \n  \n#从当前跟踪列表移除文件，并完全删除  \ngit rm readme.txt  \n  \n#仅在暂存区删除，保留文件在当前目录，不再跟踪  \ngit rm –cached readme.txt  \n  \n#重命名文件  \ngit mv reademe.txt readme  \n  \n#查看提交的历史记录  \ngit log  \n  \n#修改最后一次提交注释的，利用–amend参数  \ngit commit --amend  \n  \n#忘记提交某些修改，下面的三条命令只会得到一个提交。  \ngit commit –m &quot;add readme.txt&quot;  \ngit add readme_forgotten  \ngit commit –amend  \n  \n#假设你已经使用git add .，将修改过的文件a、b加到暂存区  \n  \n#现在你只想提交a文件，不想提交b文件，应该这样  \ngit reset HEAD b  \n  \n#取消对文件的修改  \ngit checkout –- readme.txt  \n</code></pre>\n---\n查看、添加、提交、删除、找回，重置修改文件\n\n<pre><code>\ngit help <command>  # 显示command的help  \ngit show            # 显示某次提交的内容  \n\ngit add <file>      # 将工作文件修改提交到本地暂存区  \ngit add .           # 将所有修改过的工作文件提交暂存区  \n   \ngit rm <file>       # 从版本库中删除文件  \ngit rm <file> --cached  # 从版本库中删除文件，但不删除文件  \n   \ngit reset <file>    # 从暂存区恢复到工作文件  \ngit reset -- .      # 从暂存区恢复到工作文件  \ngit reset --hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改  \n\ngit revert <$id>    # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象  \ngit revert HEAD     # 恢复最后一次提交的状态  \n\n</code></pre>\n\n---\n查看文件diff\n\n<pre><code>\ngit diff <file>     # 比较当前文件和暂存区文件差异  \ngit diff  \ngit diff <$id1> <$id2>   # 比较两次提交之间的差异  \ngit diff <branch1>..<branch2> # 在两个分支之间比较  \ngit diff --staged   # 比较暂存区和版本库差异  \ngit diff --cached   # 比较暂存区和版本库差异  \ngit diff --stat     # 仅仅比较统计信息  \n</code></pre>\n\n---\n查看提交记录\n\n<pre><code>\ngit log  \ngit log <file>      # 查看该文件每次提交记录  \ngit log -p <file>   # 查看每次详细修改内容的diff  \ngit log -p -2       # 查看最近两次详细修改内容的diff  \ngit log --stat      #查看提交统计信息  \n</code></pre>\n\n\n---\n查看、切换、创建和删除分支\n\n<pre><code>\ngit br -r           # 查看远程分支  \ngit br <new_branch> # 创建新的分支  \ngit br -v           # 查看各个分支最后提交信息  \ngit br --merged     # 查看已经被合并到当前分支的分支  \ngit br --no-merged  # 查看尚未被合并到当前分支的分支  \n   \ngit co <branch>     # 切换到某个分支  \ngit co -b <new_branch> # 创建新的分支，并且切换过去  \ngit co -b <new_branch> <branch>  # 基于branch创建新的new_branch  \n   \ngit co $id          # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除  \ngit co $id -b <new_branch>  # 把某次历史提交记录checkout出来，创建成一个分支  \n   \ngit br -d <branch>  # 删除某个分支  \ngit br -D <branch>  # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)  \n</code></pre>\n\n---\nGit远程分支管理\n\n<pre><code>\ngit pull                         # 抓取远程仓库所有分支更新并合并到本地  \ngit pull --no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并  \ngit fetch origin                 # 抓取远程仓库更新  \ngit merge origin/master          # 将远程主分支合并到本地当前分支  \ngit co --track origin/branch     # 跟踪某个远程分支创建相应的本地分支  \ngit co -b <local_branch> origin/<remote_branch>  # 基于远程分支创建本地分支，功能同上  \n   \ngit push                         # push所有分支  \ngit push origin master           # 将本地主分支推到远程主分支  \ngit push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)  \ngit push origin <local_branch>   # 创建远程分支， origin是远程仓库名  \ngit push origin <local_branch>:<remote_branch>  # 创建远程分支  \ngit push origin :<remote_branch>  #先删除本地分支(git br -d <branch>)，然后再push删除远程分支  \n</code></pre>\n","source":"_posts/git常用命令行.md","raw":"---\ntitle: git常用命令行\ndate: 2016-10-25 15:59:54\ntags:\n---\n### 1.修改.gitignore为全局的方法\n\n直接修改.gitconfig内容，加上\n[core]excludesfile = /Users/你的账户文件夹/.gitignore_global\n\n### 2.如何编辑mac系统中的全局gitignore文件？\n\n在根目录下vim .gitignore_global\n\n### 3.配置语法：\n\n以斜杠“/”开头表示目录；\n\n以星号“*”通配多个字符；\n\n以问号“?”通配单个字符；\n\n以方括号“[]”包含单个字符的匹配列表；\n\n以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；\n\n此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效。\n\n\n---\n最常用的\n\n之前一直使用sourcetree来提交代码，现在准备改用命令行来提交。\n\n按照之前sourcetree的逻辑，推送代码前先提交代码到本地git仓库，然后拉取代码，再合并代码。最后推送到远程服务器上。\n\n添加代码对应git add\n\n提交代码对应git commit -m '提交说明'\n\n拉取代码对应git pull\n\n推送代码对应git push\n\n查看当前未提交代码  git status\n\n---\n补充\n\n---\n初始化配置\n\n<pre><code>\n#配置使用git仓库的人员姓名  \ngit config --global user.name \"Your Name Comes Here\"  \n  \n#配置使用git仓库的人员email  \ngit config --global user.email you@yourdomain.example.com  \n</code></pre>\n\n\n---\n取得Git仓库\n\n<pre><code>\n#初始化一个版本仓库  \ngit init  \n  \n#Clone远程版本库  \ngit clone git@github.com:darrenfantasy/darrenfantasy.github.io.git \n  \n#添加远程版本库origin，语法为 git remote add [shortname] [url]  \ngit remote add origin git@github.com:darrenfantasy/darrenfantasy.github.io.git  \n  \n#查看远程仓库  \ngit remote -v  \n</code></pre>\n\n---\n提交你的修改\n\n<pre><code>\n#添加当前修改的文件到暂存区  \ngit add .  \n  \n#如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件  \ngit add -u  \n  \n#提交你的修改  \ngit commit –m \"你的注释\"  \n  \n#推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支]  \ngit push origin master  \n  \n#查看文件状态  \ngit status  \n  \n#跟踪新文件  \ngit add readme.txt  \n  \n#从当前跟踪列表移除文件，并完全删除  \ngit rm readme.txt  \n  \n#仅在暂存区删除，保留文件在当前目录，不再跟踪  \ngit rm –cached readme.txt  \n  \n#重命名文件  \ngit mv reademe.txt readme  \n  \n#查看提交的历史记录  \ngit log  \n  \n#修改最后一次提交注释的，利用–amend参数  \ngit commit --amend  \n  \n#忘记提交某些修改，下面的三条命令只会得到一个提交。  \ngit commit –m &quot;add readme.txt&quot;  \ngit add readme_forgotten  \ngit commit –amend  \n  \n#假设你已经使用git add .，将修改过的文件a、b加到暂存区  \n  \n#现在你只想提交a文件，不想提交b文件，应该这样  \ngit reset HEAD b  \n  \n#取消对文件的修改  \ngit checkout –- readme.txt  \n</code></pre>\n---\n查看、添加、提交、删除、找回，重置修改文件\n\n<pre><code>\ngit help <command>  # 显示command的help  \ngit show            # 显示某次提交的内容  \n\ngit add <file>      # 将工作文件修改提交到本地暂存区  \ngit add .           # 将所有修改过的工作文件提交暂存区  \n   \ngit rm <file>       # 从版本库中删除文件  \ngit rm <file> --cached  # 从版本库中删除文件，但不删除文件  \n   \ngit reset <file>    # 从暂存区恢复到工作文件  \ngit reset -- .      # 从暂存区恢复到工作文件  \ngit reset --hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改  \n\ngit revert <$id>    # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象  \ngit revert HEAD     # 恢复最后一次提交的状态  \n\n</code></pre>\n\n---\n查看文件diff\n\n<pre><code>\ngit diff <file>     # 比较当前文件和暂存区文件差异  \ngit diff  \ngit diff <$id1> <$id2>   # 比较两次提交之间的差异  \ngit diff <branch1>..<branch2> # 在两个分支之间比较  \ngit diff --staged   # 比较暂存区和版本库差异  \ngit diff --cached   # 比较暂存区和版本库差异  \ngit diff --stat     # 仅仅比较统计信息  \n</code></pre>\n\n---\n查看提交记录\n\n<pre><code>\ngit log  \ngit log <file>      # 查看该文件每次提交记录  \ngit log -p <file>   # 查看每次详细修改内容的diff  \ngit log -p -2       # 查看最近两次详细修改内容的diff  \ngit log --stat      #查看提交统计信息  \n</code></pre>\n\n\n---\n查看、切换、创建和删除分支\n\n<pre><code>\ngit br -r           # 查看远程分支  \ngit br <new_branch> # 创建新的分支  \ngit br -v           # 查看各个分支最后提交信息  \ngit br --merged     # 查看已经被合并到当前分支的分支  \ngit br --no-merged  # 查看尚未被合并到当前分支的分支  \n   \ngit co <branch>     # 切换到某个分支  \ngit co -b <new_branch> # 创建新的分支，并且切换过去  \ngit co -b <new_branch> <branch>  # 基于branch创建新的new_branch  \n   \ngit co $id          # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除  \ngit co $id -b <new_branch>  # 把某次历史提交记录checkout出来，创建成一个分支  \n   \ngit br -d <branch>  # 删除某个分支  \ngit br -D <branch>  # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)  \n</code></pre>\n\n---\nGit远程分支管理\n\n<pre><code>\ngit pull                         # 抓取远程仓库所有分支更新并合并到本地  \ngit pull --no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并  \ngit fetch origin                 # 抓取远程仓库更新  \ngit merge origin/master          # 将远程主分支合并到本地当前分支  \ngit co --track origin/branch     # 跟踪某个远程分支创建相应的本地分支  \ngit co -b <local_branch> origin/<remote_branch>  # 基于远程分支创建本地分支，功能同上  \n   \ngit push                         # push所有分支  \ngit push origin master           # 将本地主分支推到远程主分支  \ngit push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)  \ngit push origin <local_branch>   # 创建远程分支， origin是远程仓库名  \ngit push origin <local_branch>:<remote_branch>  # 创建远程分支  \ngit push origin :<remote_branch>  #先删除本地分支(git br -d <branch>)，然后再push删除远程分支  \n</code></pre>\n","slug":"git常用命令行","published":1,"updated":"2017-02-15T08:00:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6pq00051kgfhlu7gs3p","content":"<h3 id=\"1-修改-gitignore为全局的方法\"><a href=\"#1-修改-gitignore为全局的方法\" class=\"headerlink\" title=\"1.修改.gitignore为全局的方法\"></a>1.修改.gitignore为全局的方法</h3><p>直接修改.gitconfig内容，加上<br>[core]excludesfile = /Users/你的账户文件夹/.gitignore_global</p>\n<h3 id=\"2-如何编辑mac系统中的全局gitignore文件？\"><a href=\"#2-如何编辑mac系统中的全局gitignore文件？\" class=\"headerlink\" title=\"2.如何编辑mac系统中的全局gitignore文件？\"></a>2.如何编辑mac系统中的全局gitignore文件？</h3><p>在根目录下vim .gitignore_global</p>\n<h3 id=\"3-配置语法：\"><a href=\"#3-配置语法：\" class=\"headerlink\" title=\"3.配置语法：\"></a>3.配置语法：</h3><p>以斜杠“/”开头表示目录；</p>\n<p>以星号“*”通配多个字符；</p>\n<p>以问号“?”通配单个字符；</p>\n<p>以方括号“[]”包含单个字符的匹配列表；</p>\n<p>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p>\n<p>此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效。</p>\n<hr>\n<p>最常用的</p>\n<p>之前一直使用sourcetree来提交代码，现在准备改用命令行来提交。</p>\n<p>按照之前sourcetree的逻辑，推送代码前先提交代码到本地git仓库，然后拉取代码，再合并代码。最后推送到远程服务器上。</p>\n<p>添加代码对应git add</p>\n<p>提交代码对应git commit -m ‘提交说明’</p>\n<p>拉取代码对应git pull</p>\n<p>推送代码对应git push</p>\n<p>查看当前未提交代码  git status</p>\n<hr>\n<p>补充</p>\n<hr>\n<p>初始化配置</p>\n<pre><code>\n#配置使用git仓库的人员姓名  \ngit config --global user.name \"Your Name Comes Here\"  \n\n#配置使用git仓库的人员email  \ngit config --global user.email you@yourdomain.example.com  \n</code></pre>\n\n\n<hr>\n<p>取得Git仓库</p>\n<pre><code>\n#初始化一个版本仓库  \ngit init  \n\n#Clone远程版本库  \ngit clone git@github.com:darrenfantasy/darrenfantasy.github.io.git \n\n#添加远程版本库origin，语法为 git remote add [shortname] [url]  \ngit remote add origin git@github.com:darrenfantasy/darrenfantasy.github.io.git  \n\n#查看远程仓库  \ngit remote -v  \n</code></pre>\n\n<hr>\n<p>提交你的修改</p>\n<pre><code>\n#添加当前修改的文件到暂存区  \ngit add .  \n\n#如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件  \ngit add -u  \n\n#提交你的修改  \ngit commit –m \"你的注释\"  \n\n#推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支]  \ngit push origin master  \n\n#查看文件状态  \ngit status  \n\n#跟踪新文件  \ngit add readme.txt  \n\n#从当前跟踪列表移除文件，并完全删除  \ngit rm readme.txt  \n\n#仅在暂存区删除，保留文件在当前目录，不再跟踪  \ngit rm –cached readme.txt  \n\n#重命名文件  \ngit mv reademe.txt readme  \n\n#查看提交的历史记录  \ngit log  \n\n#修改最后一次提交注释的，利用–amend参数  \ngit commit --amend  \n\n#忘记提交某些修改，下面的三条命令只会得到一个提交。  \ngit commit –m &quot;add readme.txt&quot;  \ngit add readme_forgotten  \ngit commit –amend  \n\n#假设你已经使用git add .，将修改过的文件a、b加到暂存区  \n\n#现在你只想提交a文件，不想提交b文件，应该这样  \ngit reset HEAD b  \n\n#取消对文件的修改  \ngit checkout –- readme.txt  \n</code></pre>\n---\n查看、添加、提交、删除、找回，重置修改文件\n\n<pre><code>\ngit help <command>  # 显示command的help  \ngit show            # 显示某次提交的内容  \n\ngit add <file>      # 将工作文件修改提交到本地暂存区  \ngit add .           # 将所有修改过的工作文件提交暂存区  \n\ngit rm <file>       # 从版本库中删除文件  \ngit rm <file> --cached  # 从版本库中删除文件，但不删除文件  \n\ngit reset <file>    # 从暂存区恢复到工作文件  \ngit reset -- .      # 从暂存区恢复到工作文件  \ngit reset --hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改  \n\ngit revert <$id>    # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象  \ngit revert HEAD     # 恢复最后一次提交的状态  \n\n</$id></file></file></file></file></code></pre>\n\n<hr>\n<p>查看文件diff</p>\n<pre><code>\ngit diff <file>     # 比较当前文件和暂存区文件差异  \ngit diff  \ngit diff <$id1> <$id2>   # 比较两次提交之间的差异  \ngit diff <branch1>..<branch2> # 在两个分支之间比较  \ngit diff --staged   # 比较暂存区和版本库差异  \ngit diff --cached   # 比较暂存区和版本库差异  \ngit diff --stat     # 仅仅比较统计信息  \n</branch2></branch1></$id2></$id1></file></code></pre>\n\n<hr>\n<p>查看提交记录</p>\n<pre><code>\ngit log  \ngit log <file>      # 查看该文件每次提交记录  \ngit log -p <file>   # 查看每次详细修改内容的diff  \ngit log -p -2       # 查看最近两次详细修改内容的diff  \ngit log --stat      #查看提交统计信息  \n</file></file></code></pre>\n\n\n<hr>\n<p>查看、切换、创建和删除分支</p>\n<pre><code>\ngit br -r           # 查看远程分支  \ngit br <new_branch> # 创建新的分支  \ngit br -v           # 查看各个分支最后提交信息  \ngit br --merged     # 查看已经被合并到当前分支的分支  \ngit br --no-merged  # 查看尚未被合并到当前分支的分支  \n\ngit co <branch>     # 切换到某个分支  \ngit co -b <new_branch> # 创建新的分支，并且切换过去  \ngit co -b <new_branch> <branch>  # 基于branch创建新的new_branch  \n\ngit co $id          # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除  \ngit co $id -b <new_branch>  # 把某次历史提交记录checkout出来，创建成一个分支  \n\ngit br -d <branch>  # 删除某个分支  \ngit br -D <branch>  # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)  \n</branch></branch></new_branch></branch></new_branch></new_branch></branch></new_branch></code></pre>\n\n<hr>\n<p>Git远程分支管理</p>\n<pre><code>\ngit pull                         # 抓取远程仓库所有分支更新并合并到本地  \ngit pull --no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并  \ngit fetch origin                 # 抓取远程仓库更新  \ngit merge origin/master          # 将远程主分支合并到本地当前分支  \ngit co --track origin/branch     # 跟踪某个远程分支创建相应的本地分支  \ngit co -b <local_branch> origin/<remote_branch>  # 基于远程分支创建本地分支，功能同上  \n\ngit push                         # push所有分支  \ngit push origin master           # 将本地主分支推到远程主分支  \ngit push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)  \ngit push origin <local_branch>   # 创建远程分支， origin是远程仓库名  \ngit push origin <local_branch>:<remote_branch>  # 创建远程分支  \ngit push origin :<remote_branch>  #先删除本地分支(git br -d <branch>)，然后再push删除远程分支  \n</branch></remote_branch></remote_branch></local_branch></local_branch></remote_branch></local_branch></code></pre>\n","excerpt":"","more":"<h3 id=\"1-修改-gitignore为全局的方法\"><a href=\"#1-修改-gitignore为全局的方法\" class=\"headerlink\" title=\"1.修改.gitignore为全局的方法\"></a>1.修改.gitignore为全局的方法</h3><p>直接修改.gitconfig内容，加上<br>[core]excludesfile = /Users/你的账户文件夹/.gitignore_global</p>\n<h3 id=\"2-如何编辑mac系统中的全局gitignore文件？\"><a href=\"#2-如何编辑mac系统中的全局gitignore文件？\" class=\"headerlink\" title=\"2.如何编辑mac系统中的全局gitignore文件？\"></a>2.如何编辑mac系统中的全局gitignore文件？</h3><p>在根目录下vim .gitignore_global</p>\n<h3 id=\"3-配置语法：\"><a href=\"#3-配置语法：\" class=\"headerlink\" title=\"3.配置语法：\"></a>3.配置语法：</h3><p>以斜杠“/”开头表示目录；</p>\n<p>以星号“*”通配多个字符；</p>\n<p>以问号“?”通配单个字符；</p>\n<p>以方括号“[]”包含单个字符的匹配列表；</p>\n<p>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；</p>\n<p>此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效。</p>\n<hr>\n<p>最常用的</p>\n<p>之前一直使用sourcetree来提交代码，现在准备改用命令行来提交。</p>\n<p>按照之前sourcetree的逻辑，推送代码前先提交代码到本地git仓库，然后拉取代码，再合并代码。最后推送到远程服务器上。</p>\n<p>添加代码对应git add</p>\n<p>提交代码对应git commit -m ‘提交说明’</p>\n<p>拉取代码对应git pull</p>\n<p>推送代码对应git push</p>\n<p>查看当前未提交代码  git status</p>\n<hr>\n<p>补充</p>\n<hr>\n<p>初始化配置</p>\n<pre><code>\n#配置使用git仓库的人员姓名  \ngit config --global user.name \"Your Name Comes Here\"  \n\n#配置使用git仓库的人员email  \ngit config --global user.email you@yourdomain.example.com  \n</code></pre>\n\n\n<hr>\n<p>取得Git仓库</p>\n<pre><code>\n#初始化一个版本仓库  \ngit init  \n\n#Clone远程版本库  \ngit clone git@github.com:darrenfantasy/darrenfantasy.github.io.git \n\n#添加远程版本库origin，语法为 git remote add [shortname] [url]  \ngit remote add origin git@github.com:darrenfantasy/darrenfantasy.github.io.git  \n\n#查看远程仓库  \ngit remote -v  \n</code></pre>\n\n<hr>\n<p>提交你的修改</p>\n<pre><code>\n#添加当前修改的文件到暂存区  \ngit add .  \n\n#如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件  \ngit add -u  \n\n#提交你的修改  \ngit commit –m \"你的注释\"  \n\n#推送你的更新到远程服务器,语法为 git push [远程名] [本地分支]:[远程分支]  \ngit push origin master  \n\n#查看文件状态  \ngit status  \n\n#跟踪新文件  \ngit add readme.txt  \n\n#从当前跟踪列表移除文件，并完全删除  \ngit rm readme.txt  \n\n#仅在暂存区删除，保留文件在当前目录，不再跟踪  \ngit rm –cached readme.txt  \n\n#重命名文件  \ngit mv reademe.txt readme  \n\n#查看提交的历史记录  \ngit log  \n\n#修改最后一次提交注释的，利用–amend参数  \ngit commit --amend  \n\n#忘记提交某些修改，下面的三条命令只会得到一个提交。  \ngit commit –m &quot;add readme.txt&quot;  \ngit add readme_forgotten  \ngit commit –amend  \n\n#假设你已经使用git add .，将修改过的文件a、b加到暂存区  \n\n#现在你只想提交a文件，不想提交b文件，应该这样  \ngit reset HEAD b  \n\n#取消对文件的修改  \ngit checkout –- readme.txt  \n</code></pre>\n---\n查看、添加、提交、删除、找回，重置修改文件\n\n<pre><code>\ngit help <command>  # 显示command的help  \ngit show            # 显示某次提交的内容  \n\ngit add <file>      # 将工作文件修改提交到本地暂存区  \ngit add .           # 将所有修改过的工作文件提交暂存区  \n\ngit rm <file>       # 从版本库中删除文件  \ngit rm <file> --cached  # 从版本库中删除文件，但不删除文件  \n\ngit reset <file>    # 从暂存区恢复到工作文件  \ngit reset -- .      # 从暂存区恢复到工作文件  \ngit reset --hard    # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改  \n\ngit revert <$id>    # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象  \ngit revert HEAD     # 恢复最后一次提交的状态  \n\n</code></pre>\n\n<hr>\n<p>查看文件diff</p>\n<pre><code>\ngit diff <file>     # 比较当前文件和暂存区文件差异  \ngit diff  \ngit diff <$id1> <$id2>   # 比较两次提交之间的差异  \ngit diff <branch1>..<branch2> # 在两个分支之间比较  \ngit diff --staged   # 比较暂存区和版本库差异  \ngit diff --cached   # 比较暂存区和版本库差异  \ngit diff --stat     # 仅仅比较统计信息  \n</code></pre>\n\n<hr>\n<p>查看提交记录</p>\n<pre><code>\ngit log  \ngit log <file>      # 查看该文件每次提交记录  \ngit log -p <file>   # 查看每次详细修改内容的diff  \ngit log -p -2       # 查看最近两次详细修改内容的diff  \ngit log --stat      #查看提交统计信息  \n</code></pre>\n\n\n<hr>\n<p>查看、切换、创建和删除分支</p>\n<pre><code>\ngit br -r           # 查看远程分支  \ngit br <new_branch> # 创建新的分支  \ngit br -v           # 查看各个分支最后提交信息  \ngit br --merged     # 查看已经被合并到当前分支的分支  \ngit br --no-merged  # 查看尚未被合并到当前分支的分支  \n\ngit co <branch>     # 切换到某个分支  \ngit co -b <new_branch> # 创建新的分支，并且切换过去  \ngit co -b <new_branch> <branch>  # 基于branch创建新的new_branch  \n\ngit co $id          # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除  \ngit co $id -b <new_branch>  # 把某次历史提交记录checkout出来，创建成一个分支  \n\ngit br -d <branch>  # 删除某个分支  \ngit br -D <branch>  # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)  \n</code></pre>\n\n<hr>\n<p>Git远程分支管理</p>\n<pre><code>\ngit pull                         # 抓取远程仓库所有分支更新并合并到本地  \ngit pull --no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并  \ngit fetch origin                 # 抓取远程仓库更新  \ngit merge origin/master          # 将远程主分支合并到本地当前分支  \ngit co --track origin/branch     # 跟踪某个远程分支创建相应的本地分支  \ngit co -b <local_branch> origin/<remote_branch>  # 基于远程分支创建本地分支，功能同上  \n\ngit push                         # push所有分支  \ngit push origin master           # 将本地主分支推到远程主分支  \ngit push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)  \ngit push origin <local_branch>   # 创建远程分支， origin是远程仓库名  \ngit push origin <local_branch>:<remote_branch>  # 创建远程分支  \ngit push origin :<remote_branch>  #先删除本地分支(git br -d <branch>)，然后再push删除远程分支  \n</code></pre>\n"},{"title":"bitmap","date":"2016-09-27T07:44:20.000Z","_content":"整理了一些在学习和开发中遇到的关于bitmap相关的知识。\n\n\n---\n\n\n—inBitmap（2016-09-13）\n-----\n\n最近公司需要开发一个可以播放动画的imageView,为了节约内存，每次内存里只存一个bitmap,但是发现memory波动还是比较大，后来研究发现inBitmap可以实现内存块的复用。以下为整理后的知识点。\n\nBitmapFactory.Options 里的inBitmap属性可以实现复用内存块，不需要给这个bitmap重新申请新的内存块，避免了一次内存的分配和回收，从而提高了运行效率。\n\n\ninBitmap只能在3.0以后使用。\n\n\n使用inBitmap,在4.4之前（SDK 11- 18），只能重用大小相同的bitmap内存区域。4.4之后可以重用任何bitmap区域内存，只要这个内存比将要分配的bitmap内存大即可。\n\n---\n\n\n—Bitmap占用内存计算（2016-09-27）\n-----\n\n\nBitmap占用内存决定因素\n\n－图片的像素点个数\n\n－单位像素占用的字节数\n\nbitmap大小＝图片长度(像素)*图片宽度(像素)*单位像素占用的字节数\n\n\n单位像素所占的字节数与图片的解码方式有关。\n\n\nALPHA_8 只存储透明度信息而无颜色值\n\nARGB_8888 把每个像素点的透明度，R，G，B色值都用一个byte表示。所以需要4个字节的空间来存储一个像素点。\n\nRGB_565 不存储像素点的透明度，而且用5bit表示R值，6bit表示G值，5bit表示B值，即共16bit，也就是2个字节的空间来存储一个像素点。\n\n\n所以对同一张图片进行解码时，使用RGB_565的方式解码所占内存空间仅仅是ARGB_8888的50%。","source":"_posts/bitmap.md","raw":"---\ntitle: bitmap\ndate: 2016-09-27 15:44:20\ntags:\n---\n整理了一些在学习和开发中遇到的关于bitmap相关的知识。\n\n\n---\n\n\n—inBitmap（2016-09-13）\n-----\n\n最近公司需要开发一个可以播放动画的imageView,为了节约内存，每次内存里只存一个bitmap,但是发现memory波动还是比较大，后来研究发现inBitmap可以实现内存块的复用。以下为整理后的知识点。\n\nBitmapFactory.Options 里的inBitmap属性可以实现复用内存块，不需要给这个bitmap重新申请新的内存块，避免了一次内存的分配和回收，从而提高了运行效率。\n\n\ninBitmap只能在3.0以后使用。\n\n\n使用inBitmap,在4.4之前（SDK 11- 18），只能重用大小相同的bitmap内存区域。4.4之后可以重用任何bitmap区域内存，只要这个内存比将要分配的bitmap内存大即可。\n\n---\n\n\n—Bitmap占用内存计算（2016-09-27）\n-----\n\n\nBitmap占用内存决定因素\n\n－图片的像素点个数\n\n－单位像素占用的字节数\n\nbitmap大小＝图片长度(像素)*图片宽度(像素)*单位像素占用的字节数\n\n\n单位像素所占的字节数与图片的解码方式有关。\n\n\nALPHA_8 只存储透明度信息而无颜色值\n\nARGB_8888 把每个像素点的透明度，R，G，B色值都用一个byte表示。所以需要4个字节的空间来存储一个像素点。\n\nRGB_565 不存储像素点的透明度，而且用5bit表示R值，6bit表示G值，5bit表示B值，即共16bit，也就是2个字节的空间来存储一个像素点。\n\n\n所以对同一张图片进行解码时，使用RGB_565的方式解码所占内存空间仅仅是ARGB_8888的50%。","slug":"bitmap","published":1,"updated":"2017-02-15T07:46:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6ps00061kgfr5ildqg5","content":"<p>整理了一些在学习和开发中遇到的关于bitmap相关的知识。</p>\n<hr>\n<h2 id=\"—inBitmap（2016-09-13）\"><a href=\"#—inBitmap（2016-09-13）\" class=\"headerlink\" title=\"—inBitmap（2016-09-13）\"></a>—inBitmap（2016-09-13）</h2><p>最近公司需要开发一个可以播放动画的imageView,为了节约内存，每次内存里只存一个bitmap,但是发现memory波动还是比较大，后来研究发现inBitmap可以实现内存块的复用。以下为整理后的知识点。</p>\n<p>BitmapFactory.Options 里的inBitmap属性可以实现复用内存块，不需要给这个bitmap重新申请新的内存块，避免了一次内存的分配和回收，从而提高了运行效率。</p>\n<p>inBitmap只能在3.0以后使用。</p>\n<p>使用inBitmap,在4.4之前（SDK 11- 18），只能重用大小相同的bitmap内存区域。4.4之后可以重用任何bitmap区域内存，只要这个内存比将要分配的bitmap内存大即可。</p>\n<hr>\n<h2 id=\"—Bitmap占用内存计算（2016-09-27）\"><a href=\"#—Bitmap占用内存计算（2016-09-27）\" class=\"headerlink\" title=\"—Bitmap占用内存计算（2016-09-27）\"></a>—Bitmap占用内存计算（2016-09-27）</h2><p>Bitmap占用内存决定因素</p>\n<p>－图片的像素点个数</p>\n<p>－单位像素占用的字节数</p>\n<p>bitmap大小＝图片长度(像素)<em>图片宽度(像素)</em>单位像素占用的字节数</p>\n<p>单位像素所占的字节数与图片的解码方式有关。</p>\n<p>ALPHA_8 只存储透明度信息而无颜色值</p>\n<p>ARGB_8888 把每个像素点的透明度，R，G，B色值都用一个byte表示。所以需要4个字节的空间来存储一个像素点。</p>\n<p>RGB_565 不存储像素点的透明度，而且用5bit表示R值，6bit表示G值，5bit表示B值，即共16bit，也就是2个字节的空间来存储一个像素点。</p>\n<p>所以对同一张图片进行解码时，使用RGB_565的方式解码所占内存空间仅仅是ARGB_8888的50%。</p>\n","excerpt":"","more":"<p>整理了一些在学习和开发中遇到的关于bitmap相关的知识。</p>\n<hr>\n<h2 id=\"—inBitmap（2016-09-13）\"><a href=\"#—inBitmap（2016-09-13）\" class=\"headerlink\" title=\"—inBitmap（2016-09-13）\"></a>—inBitmap（2016-09-13）</h2><p>最近公司需要开发一个可以播放动画的imageView,为了节约内存，每次内存里只存一个bitmap,但是发现memory波动还是比较大，后来研究发现inBitmap可以实现内存块的复用。以下为整理后的知识点。</p>\n<p>BitmapFactory.Options 里的inBitmap属性可以实现复用内存块，不需要给这个bitmap重新申请新的内存块，避免了一次内存的分配和回收，从而提高了运行效率。</p>\n<p>inBitmap只能在3.0以后使用。</p>\n<p>使用inBitmap,在4.4之前（SDK 11- 18），只能重用大小相同的bitmap内存区域。4.4之后可以重用任何bitmap区域内存，只要这个内存比将要分配的bitmap内存大即可。</p>\n<hr>\n<h2 id=\"—Bitmap占用内存计算（2016-09-27）\"><a href=\"#—Bitmap占用内存计算（2016-09-27）\" class=\"headerlink\" title=\"—Bitmap占用内存计算（2016-09-27）\"></a>—Bitmap占用内存计算（2016-09-27）</h2><p>Bitmap占用内存决定因素</p>\n<p>－图片的像素点个数</p>\n<p>－单位像素占用的字节数</p>\n<p>bitmap大小＝图片长度(像素)<em>图片宽度(像素)</em>单位像素占用的字节数</p>\n<p>单位像素所占的字节数与图片的解码方式有关。</p>\n<p>ALPHA_8 只存储透明度信息而无颜色值</p>\n<p>ARGB_8888 把每个像素点的透明度，R，G，B色值都用一个byte表示。所以需要4个字节的空间来存储一个像素点。</p>\n<p>RGB_565 不存储像素点的透明度，而且用5bit表示R值，6bit表示G值，5bit表示B值，即共16bit，也就是2个字节的空间来存储一个像素点。</p>\n<p>所以对同一张图片进行解码时，使用RGB_565的方式解码所占内存空间仅仅是ARGB_8888的50%。</p>\n"},{"title":"adb命令","date":"2016-10-25T07:58:40.000Z","_content":"\nadb(Android Debug Bridge)是android sdk里的一个工具。\n\n可以用来运行设备shell命令\n计算机和设备之间上传和下载文件\n可将apk文件安装到安卓机设备上\nadb 命令\n\nhttps://developer.android.com/studio/command-line/adb.html#IntentSpec\n\n\n\n\nadb shell 命令\n\nhttps://developer.android.com/studio/command-line/shell.html#shellcommands\n\nadb shell 命令包括am(activity manager)和pm(package manager)\n\n关于一些am命令的介绍：\n\nstart [options] <INTENT> ：启动activity通过指定的intent参数。具体intent参数参照官方表。\n\nstartservice [options] <INTENT> ： 启动service通过指定的intent参数。具体intent跟start命令参数相同。\n\nforce-stop <PACKAGE> ： 强制停止指定的package包应用。\n\nkill [options] <PACKAGE> ：杀死指定package包应用进程，该命令在安全模式下杀死进程，不影响用户体验。参数选项：--user <USER_ID> | all | current: 指定user进程杀死，如果不指定默认为所有users。（关于USER_ID下面会介绍到）\n\nkill-all ：杀死所有的后台进程。\n\nbroadcast [options] <INTENT> ：发送一个intent。具体intent参数参照start命令参数。参数选项：--user <USER_ID> | all | current: 指定user进程杀死，如果不指定默认为所有users。\n\ninstrument [options] <COMPONENT> ：测试命令，不多作介绍。\n\nprofile start <PROCESS> <FILE> ：在<PROCESS>进程中运行profile，分析结果写到<FILE>里。\n\nprofile stop <PROCESS> ：停止profile。\n\nset-debug-app [options] <PACKAGE> ：设置package包应用为debug模式。参数选项：-w|--persistent：等待进入调试模式，保留值。\n\nclear-debug-app ：清空之前用set-debug-app命令设置的package包应用。\n\n\n接下来介绍pm命令，pm全称package manager，你能使用pm命令去模拟Android行为或者查询设备上的应用等，当你在adb shell命令下执行pm命令：\n\npm <command>\n你也可以在adb shell前执行pm命令：\nadb shell pm uninstall com.example.MyApp\n关于一些pm命令的介绍：\nlist packages [options] <FILTER> ：打印所有包，选择性的查询包列表。参数选项：-f：查看关联文件，即应用apk的位置跟对应的包名（如：package:/system/app/MusicPlayer.apk=com.sec.android.app.music）；-d：查看disabled packages；-e：查看enable package；-s：查看系统package；-3：查看第三方package；-i：查看package的对应安装者（如：1、package:com.tencent.qqmusic  installer=null 2、package:com.tencent.qqpim  installer=com.android.vending）；-u：查看曾被卸载过的package。（卸载后又重新安装依然会被列入）；--user<USER_ID>：The user space to query。\n\nlist permission-groups ：打印所有已知的权限群组。\n\nlist permissions [options] <GROUP> ：选择性的打印权限。参数选项：\n\nlist features ：设备特性。硬件之类的性能。\n\nlist libraries ：当前设备支持的libs。\n\nlist users ：系统上所有的users。（上面提到的USER_ID查询方式，如：UserInfo{0:Primary:3}那么USER_ID为0）\n\npath <PACKAGE> ：查询package的安装位置。\n\ninstall [options] <PATH> ：安装命令。\n\nuninstall [options] <PACKAGE> ：卸载命令。\n\nclear <PACKAGE> ：对指定的package删除所有数据。\n\nenable <PACKAGE_OR_COMPONENT> ：使package或component可用。（如：pm enable \"package/class\"）\n\ndisable <PACKAGE_OR_COMPONENT> ：使package或component不可用。（如：pm disable \"package/class\"）（disable了指定的package，但是getComponentEnabledSetting该package里的components依然是enable状态的。disable-user一样原理。）\n\ndisable-user [options] <PACKAGE_OR_COMPONENT> ：参数选项：--user <USER_ID>: The user to disable.\ngrant <PACKAGE_PERMISSION> ：授权给应用。\n\nrevoke <PACKAGE_PERMISSION> ：撤销权限。\n\nset-install-location <LOCATION> ：设置默认的安装位置。其中0：让系统自动选择最佳的安装位置。1：安装到内部的设备存储空间。2：安装到外部的设备存储空间。（这只用于调试应用程序，使用该命令可能导致应用程序退出或者其他不适的后果）。\n\nget-install-location ：返回当前的安装位置。返回结果同上参数选项。\n\nset-permission-enforced <PERMISSION> [true|false] ：使指定权限生效或者失效。\n\ncreate-user <USER_NAME> ：增加一个新的USER。\n\nremove-user <USER_ID> ：删除一个USER。\n\nadb push 本地文件 手机目录：把电脑上的文件发送到手机上\n\nadb pull 手机文件 本地路径：把手机上的文件拷贝到电脑里\n\nadb devices 获取当前所有online设备 serial number\n\nadb -s <serial number> shell 对某台设备进行操作","source":"_posts/adb命令.md","raw":"---\ntitle: adb命令\ndate: 2016-10-25 15:58:40\ntags:\n---\n\nadb(Android Debug Bridge)是android sdk里的一个工具。\n\n可以用来运行设备shell命令\n计算机和设备之间上传和下载文件\n可将apk文件安装到安卓机设备上\nadb 命令\n\nhttps://developer.android.com/studio/command-line/adb.html#IntentSpec\n\n\n\n\nadb shell 命令\n\nhttps://developer.android.com/studio/command-line/shell.html#shellcommands\n\nadb shell 命令包括am(activity manager)和pm(package manager)\n\n关于一些am命令的介绍：\n\nstart [options] <INTENT> ：启动activity通过指定的intent参数。具体intent参数参照官方表。\n\nstartservice [options] <INTENT> ： 启动service通过指定的intent参数。具体intent跟start命令参数相同。\n\nforce-stop <PACKAGE> ： 强制停止指定的package包应用。\n\nkill [options] <PACKAGE> ：杀死指定package包应用进程，该命令在安全模式下杀死进程，不影响用户体验。参数选项：--user <USER_ID> | all | current: 指定user进程杀死，如果不指定默认为所有users。（关于USER_ID下面会介绍到）\n\nkill-all ：杀死所有的后台进程。\n\nbroadcast [options] <INTENT> ：发送一个intent。具体intent参数参照start命令参数。参数选项：--user <USER_ID> | all | current: 指定user进程杀死，如果不指定默认为所有users。\n\ninstrument [options] <COMPONENT> ：测试命令，不多作介绍。\n\nprofile start <PROCESS> <FILE> ：在<PROCESS>进程中运行profile，分析结果写到<FILE>里。\n\nprofile stop <PROCESS> ：停止profile。\n\nset-debug-app [options] <PACKAGE> ：设置package包应用为debug模式。参数选项：-w|--persistent：等待进入调试模式，保留值。\n\nclear-debug-app ：清空之前用set-debug-app命令设置的package包应用。\n\n\n接下来介绍pm命令，pm全称package manager，你能使用pm命令去模拟Android行为或者查询设备上的应用等，当你在adb shell命令下执行pm命令：\n\npm <command>\n你也可以在adb shell前执行pm命令：\nadb shell pm uninstall com.example.MyApp\n关于一些pm命令的介绍：\nlist packages [options] <FILTER> ：打印所有包，选择性的查询包列表。参数选项：-f：查看关联文件，即应用apk的位置跟对应的包名（如：package:/system/app/MusicPlayer.apk=com.sec.android.app.music）；-d：查看disabled packages；-e：查看enable package；-s：查看系统package；-3：查看第三方package；-i：查看package的对应安装者（如：1、package:com.tencent.qqmusic  installer=null 2、package:com.tencent.qqpim  installer=com.android.vending）；-u：查看曾被卸载过的package。（卸载后又重新安装依然会被列入）；--user<USER_ID>：The user space to query。\n\nlist permission-groups ：打印所有已知的权限群组。\n\nlist permissions [options] <GROUP> ：选择性的打印权限。参数选项：\n\nlist features ：设备特性。硬件之类的性能。\n\nlist libraries ：当前设备支持的libs。\n\nlist users ：系统上所有的users。（上面提到的USER_ID查询方式，如：UserInfo{0:Primary:3}那么USER_ID为0）\n\npath <PACKAGE> ：查询package的安装位置。\n\ninstall [options] <PATH> ：安装命令。\n\nuninstall [options] <PACKAGE> ：卸载命令。\n\nclear <PACKAGE> ：对指定的package删除所有数据。\n\nenable <PACKAGE_OR_COMPONENT> ：使package或component可用。（如：pm enable \"package/class\"）\n\ndisable <PACKAGE_OR_COMPONENT> ：使package或component不可用。（如：pm disable \"package/class\"）（disable了指定的package，但是getComponentEnabledSetting该package里的components依然是enable状态的。disable-user一样原理。）\n\ndisable-user [options] <PACKAGE_OR_COMPONENT> ：参数选项：--user <USER_ID>: The user to disable.\ngrant <PACKAGE_PERMISSION> ：授权给应用。\n\nrevoke <PACKAGE_PERMISSION> ：撤销权限。\n\nset-install-location <LOCATION> ：设置默认的安装位置。其中0：让系统自动选择最佳的安装位置。1：安装到内部的设备存储空间。2：安装到外部的设备存储空间。（这只用于调试应用程序，使用该命令可能导致应用程序退出或者其他不适的后果）。\n\nget-install-location ：返回当前的安装位置。返回结果同上参数选项。\n\nset-permission-enforced <PERMISSION> [true|false] ：使指定权限生效或者失效。\n\ncreate-user <USER_NAME> ：增加一个新的USER。\n\nremove-user <USER_ID> ：删除一个USER。\n\nadb push 本地文件 手机目录：把电脑上的文件发送到手机上\n\nadb pull 手机文件 本地路径：把手机上的文件拷贝到电脑里\n\nadb devices 获取当前所有online设备 serial number\n\nadb -s <serial number> shell 对某台设备进行操作","slug":"adb命令","published":1,"updated":"2017-02-15T07:59:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6pv00071kgf2c4szy99","content":"<p>adb(Android Debug Bridge)是android sdk里的一个工具。</p>\n<p>可以用来运行设备shell命令<br>计算机和设备之间上传和下载文件<br>可将apk文件安装到安卓机设备上<br>adb 命令</p>\n<p><a href=\"https://developer.android.com/studio/command-line/adb.html#IntentSpec\" target=\"_blank\" rel=\"external\">https://developer.android.com/studio/command-line/adb.html#IntentSpec</a></p>\n<p>adb shell 命令</p>\n<p><a href=\"https://developer.android.com/studio/command-line/shell.html#shellcommands\" target=\"_blank\" rel=\"external\">https://developer.android.com/studio/command-line/shell.html#shellcommands</a></p>\n<p>adb shell 命令包括am(activity manager)和pm(package manager)</p>\n<p>关于一些am命令的介绍：</p>\n<p>start [options] <intent> ：启动activity通过指定的intent参数。具体intent参数参照官方表。</intent></p>\n<p>startservice [options] <intent> ： 启动service通过指定的intent参数。具体intent跟start命令参数相同。</intent></p>\n<p>force-stop <package> ： 强制停止指定的package包应用。</package></p>\n<p>kill [options] <package> ：杀死指定package包应用进程，该命令在安全模式下杀死进程，不影响用户体验。参数选项：–user <user_id> | all | current: 指定user进程杀死，如果不指定默认为所有users。（关于USER_ID下面会介绍到）</user_id></package></p>\n<p>kill-all ：杀死所有的后台进程。</p>\n<p>broadcast [options] <intent> ：发送一个intent。具体intent参数参照start命令参数。参数选项：–user <user_id> | all | current: 指定user进程杀死，如果不指定默认为所有users。</user_id></intent></p>\n<p>instrument [options] <component> ：测试命令，不多作介绍。</component></p>\n<p>profile start <process> <file> ：在<process>进程中运行profile，分析结果写到<file>里。</file></process></file></process></p>\n<p>profile stop <process> ：停止profile。</process></p>\n<p>set-debug-app [options] <package> ：设置package包应用为debug模式。参数选项：-w|–persistent：等待进入调试模式，保留值。</package></p>\n<p>clear-debug-app ：清空之前用set-debug-app命令设置的package包应用。</p>\n<p>接下来介绍pm命令，pm全称package manager，你能使用pm命令去模拟Android行为或者查询设备上的应用等，当你在adb shell命令下执行pm命令：</p>\n<p>pm <command><br>你也可以在adb shell前执行pm命令：<br>adb shell pm uninstall com.example.MyApp<br>关于一些pm命令的介绍：<br>list packages [options] <filter> ：打印所有包，选择性的查询包列表。参数选项：-f：查看关联文件，即应用apk的位置跟对应的包名（如：package:/system/app/MusicPlayer.apk=com.sec.android.app.music）；-d：查看disabled packages；-e：查看enable package；-s：查看系统package；-3：查看第三方package；-i：查看package的对应安装者（如：1、package:com.tencent.qqmusic  installer=null 2、package:com.tencent.qqpim  installer=com.android.vending）；-u：查看曾被卸载过的package。（卸载后又重新安装依然会被列入）；–user<user_id>：The user space to query。</user_id></filter></p>\n<p>list permission-groups ：打印所有已知的权限群组。</p>\n<p>list permissions [options] <group> ：选择性的打印权限。参数选项：</group></p>\n<p>list features ：设备特性。硬件之类的性能。</p>\n<p>list libraries ：当前设备支持的libs。</p>\n<p>list users ：系统上所有的users。（上面提到的USER_ID查询方式，如：UserInfo{0:Primary:3}那么USER_ID为0）</p>\n<p>path <package> ：查询package的安装位置。</package></p>\n<p>install [options] <path></path> ：安装命令。</p>\n<p>uninstall [options] <package> ：卸载命令。</package></p>\n<p>clear <package> ：对指定的package删除所有数据。</package></p>\n<p>enable <package_or_component> ：使package或component可用。（如：pm enable “package/class”）</package_or_component></p>\n<p>disable <package_or_component> ：使package或component不可用。（如：pm disable “package/class”）（disable了指定的package，但是getComponentEnabledSetting该package里的components依然是enable状态的。disable-user一样原理。）</package_or_component></p>\n<p>disable-user [options] <package_or_component> ：参数选项：–user <user_id>: The user to disable.<br>grant <package_permission> ：授权给应用。</package_permission></user_id></package_or_component></p>\n<p>revoke <package_permission> ：撤销权限。</package_permission></p>\n<p>set-install-location <location> ：设置默认的安装位置。其中0：让系统自动选择最佳的安装位置。1：安装到内部的设备存储空间。2：安装到外部的设备存储空间。（这只用于调试应用程序，使用该命令可能导致应用程序退出或者其他不适的后果）。</location></p>\n<p>get-install-location ：返回当前的安装位置。返回结果同上参数选项。</p>\n<p>set-permission-enforced <permission> [true|false] ：使指定权限生效或者失效。</permission></p>\n<p>create-user <user_name> ：增加一个新的USER。</user_name></p>\n<p>remove-user <user_id> ：删除一个USER。</user_id></p>\n<p>adb push 本地文件 手机目录：把电脑上的文件发送到手机上</p>\n<p>adb pull 手机文件 本地路径：把手机上的文件拷贝到电脑里</p>\n<p>adb devices 获取当前所有online设备 serial number</p>\n<p>adb -s <serial number=\"\"> shell 对某台设备进行操作</serial></p>\n","excerpt":"","more":"<p>adb(Android Debug Bridge)是android sdk里的一个工具。</p>\n<p>可以用来运行设备shell命令<br>计算机和设备之间上传和下载文件<br>可将apk文件安装到安卓机设备上<br>adb 命令</p>\n<p><a href=\"https://developer.android.com/studio/command-line/adb.html#IntentSpec\">https://developer.android.com/studio/command-line/adb.html#IntentSpec</a></p>\n<p>adb shell 命令</p>\n<p><a href=\"https://developer.android.com/studio/command-line/shell.html#shellcommands\">https://developer.android.com/studio/command-line/shell.html#shellcommands</a></p>\n<p>adb shell 命令包括am(activity manager)和pm(package manager)</p>\n<p>关于一些am命令的介绍：</p>\n<p>start [options] <INTENT> ：启动activity通过指定的intent参数。具体intent参数参照官方表。</p>\n<p>startservice [options] <INTENT> ： 启动service通过指定的intent参数。具体intent跟start命令参数相同。</p>\n<p>force-stop <PACKAGE> ： 强制停止指定的package包应用。</p>\n<p>kill [options] <PACKAGE> ：杀死指定package包应用进程，该命令在安全模式下杀死进程，不影响用户体验。参数选项：–user <USER_ID> | all | current: 指定user进程杀死，如果不指定默认为所有users。（关于USER_ID下面会介绍到）</p>\n<p>kill-all ：杀死所有的后台进程。</p>\n<p>broadcast [options] <INTENT> ：发送一个intent。具体intent参数参照start命令参数。参数选项：–user <USER_ID> | all | current: 指定user进程杀死，如果不指定默认为所有users。</p>\n<p>instrument [options] <COMPONENT> ：测试命令，不多作介绍。</p>\n<p>profile start <PROCESS> <FILE> ：在<PROCESS>进程中运行profile，分析结果写到<FILE>里。</p>\n<p>profile stop <PROCESS> ：停止profile。</p>\n<p>set-debug-app [options] <PACKAGE> ：设置package包应用为debug模式。参数选项：-w|–persistent：等待进入调试模式，保留值。</p>\n<p>clear-debug-app ：清空之前用set-debug-app命令设置的package包应用。</p>\n<p>接下来介绍pm命令，pm全称package manager，你能使用pm命令去模拟Android行为或者查询设备上的应用等，当你在adb shell命令下执行pm命令：</p>\n<p>pm <command><br>你也可以在adb shell前执行pm命令：<br>adb shell pm uninstall com.example.MyApp<br>关于一些pm命令的介绍：<br>list packages [options] <FILTER> ：打印所有包，选择性的查询包列表。参数选项：-f：查看关联文件，即应用apk的位置跟对应的包名（如：package:/system/app/MusicPlayer.apk=com.sec.android.app.music）；-d：查看disabled packages；-e：查看enable package；-s：查看系统package；-3：查看第三方package；-i：查看package的对应安装者（如：1、package:com.tencent.qqmusic  installer=null 2、package:com.tencent.qqpim  installer=com.android.vending）；-u：查看曾被卸载过的package。（卸载后又重新安装依然会被列入）；–user<USER_ID>：The user space to query。</p>\n<p>list permission-groups ：打印所有已知的权限群组。</p>\n<p>list permissions [options] <GROUP> ：选择性的打印权限。参数选项：</p>\n<p>list features ：设备特性。硬件之类的性能。</p>\n<p>list libraries ：当前设备支持的libs。</p>\n<p>list users ：系统上所有的users。（上面提到的USER_ID查询方式，如：UserInfo{0:Primary:3}那么USER_ID为0）</p>\n<p>path <PACKAGE> ：查询package的安装位置。</p>\n<p>install [options] <PATH> ：安装命令。</p>\n<p>uninstall [options] <PACKAGE> ：卸载命令。</p>\n<p>clear <PACKAGE> ：对指定的package删除所有数据。</p>\n<p>enable <PACKAGE_OR_COMPONENT> ：使package或component可用。（如：pm enable “package/class”）</p>\n<p>disable <PACKAGE_OR_COMPONENT> ：使package或component不可用。（如：pm disable “package/class”）（disable了指定的package，但是getComponentEnabledSetting该package里的components依然是enable状态的。disable-user一样原理。）</p>\n<p>disable-user [options] <PACKAGE_OR_COMPONENT> ：参数选项：–user <USER_ID>: The user to disable.<br>grant <PACKAGE_PERMISSION> ：授权给应用。</p>\n<p>revoke <PACKAGE_PERMISSION> ：撤销权限。</p>\n<p>set-install-location <LOCATION> ：设置默认的安装位置。其中0：让系统自动选择最佳的安装位置。1：安装到内部的设备存储空间。2：安装到外部的设备存储空间。（这只用于调试应用程序，使用该命令可能导致应用程序退出或者其他不适的后果）。</p>\n<p>get-install-location ：返回当前的安装位置。返回结果同上参数选项。</p>\n<p>set-permission-enforced <PERMISSION> [true|false] ：使指定权限生效或者失效。</p>\n<p>create-user <USER_NAME> ：增加一个新的USER。</p>\n<p>remove-user <USER_ID> ：删除一个USER。</p>\n<p>adb push 本地文件 手机目录：把电脑上的文件发送到手机上</p>\n<p>adb pull 手机文件 本地路径：把手机上的文件拷贝到电脑里</p>\n<p>adb devices 获取当前所有online设备 serial number</p>\n<p>adb -s <serial number> shell 对某台设备进行操作</p>\n"},{"title":"so文件","date":"2016-10-24T07:56:31.000Z","_content":".so not found cause crash\n\n今天在小米手机上运行app出现闪退情况 看了下log，发现闪退原因是.so文件找不到。然后找了下libs包下的目录，其中有四个子目录，分别是armeabi,armeabi-v7a,arm64-v8a和x86。\n\n之前不懂这几个目录的作用，今天查了下\n\narm64-v8a可以向下兼容armeabi-v7a,armeabi\n\narmeabi-v7a向下兼容armeabi\n\n但是假设一个cpu是arm64-v8a架构的手机，它运行app时去读取库文件，会先去查找是否存在arm64-v8a的文件夹，如果不存在，则去查找armeabi-v7a的文件夹，如果再不存在，则会去查找armeabi文件夹，如果这个文件夹也不存在则会抛出异常。\n\n如果有arm64-v8a文件夹，那么就会去找该文件夹下的特定的.so文件。需要注意的是，如果找不到指定.so文件，那么不会再往下（armeabi-v7a）找了，而是直接抛出异常。","source":"_posts/so文件.md","raw":"---\ntitle: so文件\ndate: 2016-10-24 15:56:31\ntags:\n---\n.so not found cause crash\n\n今天在小米手机上运行app出现闪退情况 看了下log，发现闪退原因是.so文件找不到。然后找了下libs包下的目录，其中有四个子目录，分别是armeabi,armeabi-v7a,arm64-v8a和x86。\n\n之前不懂这几个目录的作用，今天查了下\n\narm64-v8a可以向下兼容armeabi-v7a,armeabi\n\narmeabi-v7a向下兼容armeabi\n\n但是假设一个cpu是arm64-v8a架构的手机，它运行app时去读取库文件，会先去查找是否存在arm64-v8a的文件夹，如果不存在，则去查找armeabi-v7a的文件夹，如果再不存在，则会去查找armeabi文件夹，如果这个文件夹也不存在则会抛出异常。\n\n如果有arm64-v8a文件夹，那么就会去找该文件夹下的特定的.so文件。需要注意的是，如果找不到指定.so文件，那么不会再往下（armeabi-v7a）找了，而是直接抛出异常。","slug":"so文件","published":1,"updated":"2017-02-15T07:58:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6q300081kgfhs9fpnqt","content":"<p>.so not found cause crash</p>\n<p>今天在小米手机上运行app出现闪退情况 看了下log，发现闪退原因是.so文件找不到。然后找了下libs包下的目录，其中有四个子目录，分别是armeabi,armeabi-v7a,arm64-v8a和x86。</p>\n<p>之前不懂这几个目录的作用，今天查了下</p>\n<p>arm64-v8a可以向下兼容armeabi-v7a,armeabi</p>\n<p>armeabi-v7a向下兼容armeabi</p>\n<p>但是假设一个cpu是arm64-v8a架构的手机，它运行app时去读取库文件，会先去查找是否存在arm64-v8a的文件夹，如果不存在，则去查找armeabi-v7a的文件夹，如果再不存在，则会去查找armeabi文件夹，如果这个文件夹也不存在则会抛出异常。</p>\n<p>如果有arm64-v8a文件夹，那么就会去找该文件夹下的特定的.so文件。需要注意的是，如果找不到指定.so文件，那么不会再往下（armeabi-v7a）找了，而是直接抛出异常。</p>\n","excerpt":"","more":"<p>.so not found cause crash</p>\n<p>今天在小米手机上运行app出现闪退情况 看了下log，发现闪退原因是.so文件找不到。然后找了下libs包下的目录，其中有四个子目录，分别是armeabi,armeabi-v7a,arm64-v8a和x86。</p>\n<p>之前不懂这几个目录的作用，今天查了下</p>\n<p>arm64-v8a可以向下兼容armeabi-v7a,armeabi</p>\n<p>armeabi-v7a向下兼容armeabi</p>\n<p>但是假设一个cpu是arm64-v8a架构的手机，它运行app时去读取库文件，会先去查找是否存在arm64-v8a的文件夹，如果不存在，则去查找armeabi-v7a的文件夹，如果再不存在，则会去查找armeabi文件夹，如果这个文件夹也不存在则会抛出异常。</p>\n<p>如果有arm64-v8a文件夹，那么就会去找该文件夹下的特定的.so文件。需要注意的是，如果找不到指定.so文件，那么不会再往下（armeabi-v7a）找了，而是直接抛出异常。</p>\n"},{"title":"单例模式","date":"2016-10-18T07:56:19.000Z","_content":"\n---\n\n1.懒汉式\n----\n<pre><code>\npublic class Singleton{\n  private static Singleton mInstance;\n  private Singleton(){\n  }\n  public static synchronized Singleton getInstance(){\n    if(mInstance == null){\n      mInstance = new Singleton();\n    }\n    return mInstance;\n  }\n}\n</code></pre>\n\n对于懒汉式，会延迟加载，在第一次调用的时候才会初始化。如果不需要同步的情况下，效率比较低。\n\n\n2.饿汉式\n----\n<pre><code>\npublic class Singleton{\n  private static Singleton mInstance = new Singleton();\n  private Singleton(){\n  }\n  public static Singleton getInstance{\n    return mInstance;\n  }\n}\n</code></pre>\n\n对于饿汉式，类加载的时候单例就会实例化，会浪费内存。\n\n3.双重检查锁定（Double Check Lock）\n----\n<pre><code>\npublic class Singleton{\n  private static Singleton mInstance;\n  private Singleton(){\n  }\n  public static Singleton getInstance{\n    if(mInstance == null){\n      Synchronized(Singleton.class){\n        if(mInstance == null){\n          mInstance = new Singleton();\n        }\n      }\n    }\n    return mInstance;\n  }\n}\n</code></pre>\n\n在JDK1.5之后，这种方法才能达到单例效果。\n\n4.静态内部类\n----\n<pre><code>\npublic class Singleton{\n  private Singleton(){\n  }\n  public static Singleton getInstance(){\n    return SingletonHolder.mInstance;\n  }\n  private static class SingletonHolder(){\n    private static final Singleton mInstance = new Singleton();\n  }\n}\n</code></pre>","source":"_posts/单例模式.md","raw":"---\ntitle: 单例模式\ndate: 2016-10-18 15:56:19\ntags:\n---\n\n---\n\n1.懒汉式\n----\n<pre><code>\npublic class Singleton{\n  private static Singleton mInstance;\n  private Singleton(){\n  }\n  public static synchronized Singleton getInstance(){\n    if(mInstance == null){\n      mInstance = new Singleton();\n    }\n    return mInstance;\n  }\n}\n</code></pre>\n\n对于懒汉式，会延迟加载，在第一次调用的时候才会初始化。如果不需要同步的情况下，效率比较低。\n\n\n2.饿汉式\n----\n<pre><code>\npublic class Singleton{\n  private static Singleton mInstance = new Singleton();\n  private Singleton(){\n  }\n  public static Singleton getInstance{\n    return mInstance;\n  }\n}\n</code></pre>\n\n对于饿汉式，类加载的时候单例就会实例化，会浪费内存。\n\n3.双重检查锁定（Double Check Lock）\n----\n<pre><code>\npublic class Singleton{\n  private static Singleton mInstance;\n  private Singleton(){\n  }\n  public static Singleton getInstance{\n    if(mInstance == null){\n      Synchronized(Singleton.class){\n        if(mInstance == null){\n          mInstance = new Singleton();\n        }\n      }\n    }\n    return mInstance;\n  }\n}\n</code></pre>\n\n在JDK1.5之后，这种方法才能达到单例效果。\n\n4.静态内部类\n----\n<pre><code>\npublic class Singleton{\n  private Singleton(){\n  }\n  public static Singleton getInstance(){\n    return SingletonHolder.mInstance;\n  }\n  private static class SingletonHolder(){\n    private static final Singleton mInstance = new Singleton();\n  }\n}\n</code></pre>","slug":"单例模式","published":1,"updated":"2017-02-15T07:57:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6q500091kgfmmjmzg1u","content":"<hr>\n<h2 id=\"1-懒汉式\"><a href=\"#1-懒汉式\" class=\"headerlink\" title=\"1.懒汉式\"></a>1.懒汉式</h2><pre><code>\npublic class Singleton{\n  private static Singleton mInstance;\n  private Singleton(){\n  }\n  public static synchronized Singleton getInstance(){\n    if(mInstance == null){\n      mInstance = new Singleton();\n    }\n    return mInstance;\n  }\n}\n</code></pre>\n\n<p>对于懒汉式，会延迟加载，在第一次调用的时候才会初始化。如果不需要同步的情况下，效率比较低。</p>\n<h2 id=\"2-饿汉式\"><a href=\"#2-饿汉式\" class=\"headerlink\" title=\"2.饿汉式\"></a>2.饿汉式</h2><pre><code>\npublic class Singleton{\n  private static Singleton mInstance = new Singleton();\n  private Singleton(){\n  }\n  public static Singleton getInstance{\n    return mInstance;\n  }\n}\n</code></pre>\n\n<p>对于饿汉式，类加载的时候单例就会实例化，会浪费内存。</p>\n<h2 id=\"3-双重检查锁定（Double-Check-Lock）\"><a href=\"#3-双重检查锁定（Double-Check-Lock）\" class=\"headerlink\" title=\"3.双重检查锁定（Double Check Lock）\"></a>3.双重检查锁定（Double Check Lock）</h2><pre><code>\npublic class Singleton{\n  private static Singleton mInstance;\n  private Singleton(){\n  }\n  public static Singleton getInstance{\n    if(mInstance == null){\n      Synchronized(Singleton.class){\n        if(mInstance == null){\n          mInstance = new Singleton();\n        }\n      }\n    }\n    return mInstance;\n  }\n}\n</code></pre>\n\n<p>在JDK1.5之后，这种方法才能达到单例效果。</p>\n<h2 id=\"4-静态内部类\"><a href=\"#4-静态内部类\" class=\"headerlink\" title=\"4.静态内部类\"></a>4.静态内部类</h2><pre><code>\npublic class Singleton{\n  private Singleton(){\n  }\n  public static Singleton getInstance(){\n    return SingletonHolder.mInstance;\n  }\n  private static class SingletonHolder(){\n    private static final Singleton mInstance = new Singleton();\n  }\n}\n</code></pre>","excerpt":"","more":"<hr>\n<h2 id=\"1-懒汉式\"><a href=\"#1-懒汉式\" class=\"headerlink\" title=\"1.懒汉式\"></a>1.懒汉式</h2><pre><code>\npublic class Singleton{\n  private static Singleton mInstance;\n  private Singleton(){\n  }\n  public static synchronized Singleton getInstance(){\n    if(mInstance == null){\n      mInstance = new Singleton();\n    }\n    return mInstance;\n  }\n}\n</code></pre>\n\n<p>对于懒汉式，会延迟加载，在第一次调用的时候才会初始化。如果不需要同步的情况下，效率比较低。</p>\n<h2 id=\"2-饿汉式\"><a href=\"#2-饿汉式\" class=\"headerlink\" title=\"2.饿汉式\"></a>2.饿汉式</h2><pre><code>\npublic class Singleton{\n  private static Singleton mInstance = new Singleton();\n  private Singleton(){\n  }\n  public static Singleton getInstance{\n    return mInstance;\n  }\n}\n</code></pre>\n\n<p>对于饿汉式，类加载的时候单例就会实例化，会浪费内存。</p>\n<h2 id=\"3-双重检查锁定（Double-Check-Lock）\"><a href=\"#3-双重检查锁定（Double-Check-Lock）\" class=\"headerlink\" title=\"3.双重检查锁定（Double Check Lock）\"></a>3.双重检查锁定（Double Check Lock）</h2><pre><code>\npublic class Singleton{\n  private static Singleton mInstance;\n  private Singleton(){\n  }\n  public static Singleton getInstance{\n    if(mInstance == null){\n      Synchronized(Singleton.class){\n        if(mInstance == null){\n          mInstance = new Singleton();\n        }\n      }\n    }\n    return mInstance;\n  }\n}\n</code></pre>\n\n<p>在JDK1.5之后，这种方法才能达到单例效果。</p>\n<h2 id=\"4-静态内部类\"><a href=\"#4-静态内部类\" class=\"headerlink\" title=\"4.静态内部类\"></a>4.静态内部类</h2><pre><code>\npublic class Singleton{\n  private Singleton(){\n  }\n  public static Singleton getInstance(){\n    return SingletonHolder.mInstance;\n  }\n  private static class SingletonHolder(){\n    private static final Singleton mInstance = new Singleton();\n  }\n}\n</code></pre>"},{"title":"读《Android开发艺术探索》笔记","date":"2017-01-12T08:07:03.000Z","_content":"\n关于《Android开发艺术探索》学习的摘录\n\n\n---\n### 第三章View的事件体系\n\nView的top,left,right,bottom都是相当View的父容器而言的\nAndroid 3.0后增加了几个参数:x,y,translationX,translationY.\nx,y为左上角坐标，translationX,translationY是View左上角相对与父容器的偏移量。\nx = left+translationX; y = top+translationY;\nView在平移时，top和left代表代表原始左上角的坐标信息，其值不会发生变化。 \n\nMotionEvent\ngetX和getY是相对于当前View左上角的坐标而言。\ngetRawX和getRawY是相对手机屏幕左上角而言的。","source":"_posts/读《Android开发艺术探索》笔记.md","raw":"---\ntitle: 读《Android开发艺术探索》笔记\ndate: 2017-01-12 16:07:03\ntags:\n---\n\n关于《Android开发艺术探索》学习的摘录\n\n\n---\n### 第三章View的事件体系\n\nView的top,left,right,bottom都是相当View的父容器而言的\nAndroid 3.0后增加了几个参数:x,y,translationX,translationY.\nx,y为左上角坐标，translationX,translationY是View左上角相对与父容器的偏移量。\nx = left+translationX; y = top+translationY;\nView在平移时，top和left代表代表原始左上角的坐标信息，其值不会发生变化。 \n\nMotionEvent\ngetX和getY是相对于当前View左上角的坐标而言。\ngetRawX和getRawY是相对手机屏幕左上角而言的。","slug":"读《Android开发艺术探索》笔记","published":1,"updated":"2017-02-15T08:07:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6q6000a1kgfmcm5r5x4","content":"<p>关于《Android开发艺术探索》学习的摘录</p>\n<hr>\n<h3 id=\"第三章View的事件体系\"><a href=\"#第三章View的事件体系\" class=\"headerlink\" title=\"第三章View的事件体系\"></a>第三章View的事件体系</h3><p>View的top,left,right,bottom都是相当View的父容器而言的<br>Android 3.0后增加了几个参数:x,y,translationX,translationY.<br>x,y为左上角坐标，translationX,translationY是View左上角相对与父容器的偏移量。<br>x = left+translationX; y = top+translationY;<br>View在平移时，top和left代表代表原始左上角的坐标信息，其值不会发生变化。 </p>\n<p>MotionEvent<br>getX和getY是相对于当前View左上角的坐标而言。<br>getRawX和getRawY是相对手机屏幕左上角而言的。</p>\n","excerpt":"","more":"<p>关于《Android开发艺术探索》学习的摘录</p>\n<hr>\n<h3 id=\"第三章View的事件体系\"><a href=\"#第三章View的事件体系\" class=\"headerlink\" title=\"第三章View的事件体系\"></a>第三章View的事件体系</h3><p>View的top,left,right,bottom都是相当View的父容器而言的<br>Android 3.0后增加了几个参数:x,y,translationX,translationY.<br>x,y为左上角坐标，translationX,translationY是View左上角相对与父容器的偏移量。<br>x = left+translationX; y = top+translationY;<br>View在平移时，top和left代表代表原始左上角的坐标信息，其值不会发生变化。 </p>\n<p>MotionEvent<br>getX和getY是相对于当前View左上角的坐标而言。<br>getRawX和getRawY是相对手机屏幕左上角而言的。</p>\n"},{"title":"开发中遇到的坑","date":"2016-11-03T08:00:58.000Z","_content":"\n---\n2016-11-03关于Java中Integer的值的比较\n---\n\n今天在开发中，需要新增一个错误码的返回值，调试过程中发现\n\n\n Integer i = 40002;\n Integer j = 40002;\n i==j 返回false\n \n 而之前错误码0的时候确实返回true\n Integer x = 0;\n Integer y = 0;\n x==y 返回true\n \n 一时半会有点晕，打断点的时候才发现对象不一样。\n 后来查资料发现\n<pre><code>\n public static Integer valueOf(int i) {\n        return  i >= 128 || i < -128 ? new Integer(i) : SMALL_VALUES[i + 128];\n    }\n\n    /**\n     * A cache of instances used by {@link Integer#valueOf(int)} and auto-boxing\n     */\n    private static final Integer[] SMALL_VALUES = new Integer[256];\n\n    static {\n        for (int i = -128; i < 128; i++) {\n            SMALL_VALUES[i + 128] = new Integer(i);\n        }\n    }\n </code></pre>\n 默认Integer值在－127到128区间内，就会把i作为变量存到内存里。否则会new一个Integer对象。\n 所以比较Integer值的时候，可以使用Integer.intValue()或者直接用equals()比较。\n \n---\n2017-01-12开发表情搜搜demo时遇到的一些问题\n---\n\n大约一周半的时间，完成了表情搜搜demo\n以下记录了开发中遇到的问题\n\n1.Intent无法传递太大数据\n（业务需求：把后打开的页面里的一个图片的base64传到上一个页面，由于数据量过大，后改为把图片的url传回上个页面再去转成base64）\n因为遇到要在后打开的页面传递值返回到上一个页面，所以用StartActivityForResult方法。在setResult时通过Intent来把图片的base64传回去，\n但是遇到错误信息：E/JavaBinder﹕ !!! FAILED BINDER TRANSACTION !!!\n查阅资料发现  https://developer.android.com/reference/android/os/TransactionTooLargeException.html\nThe Binder transaction buffer has a limited fixed size, currently 1Mb, which is shared by all transactions in progress for the process. Consequently this exception can be thrown when there are many transactions in progress even when most of the individual transactions are of moderate size.\nBinder事务缓冲区具有有限的固定大小，目前为1Mb，由进程正在进行的所有事务共享。因此，当有许多事务正在进行时，即使大多数单独的事务大小适中，也可以抛出此异常.\n\n\n2.SharedPreferences存StringSet时，不能直接操作取出的set.否则数据会丢失\n(业务需求：缓存本地搜索记录，因为是要存10个字符串，所以一开始想简单点直接用StringSet，后来因为set无序，所以改用拼接字符串)\n查源代码发现  *<p>Note that you <em>must not</em> modify the set instance returned\n            * by this call.  The consistency of the stored data is not guaranteed\n            * if you do, nor is your ability to modify the instance at all.\n\n3.Android 防止点击事件穿透（在布局的根节点添加Android:clickable=\"true\" 属性即可，用来获取焦点防止点击事件穿透）\n\n4.自定义view为内部类时，没有将内部类设置为static \n导致java.lang.NoSuchMethodException: <init> [class android.content.Context, interface android.util.AttributeSet]\n\n5.想监听一个父布局的ontouch事件时，发现用手触摸时只打印出Action.move和up.如果点击父布局里的子控件时，什么事件都无法打印出来。\n回想了下之前View的事件分发机制，不能在重写OnTouchEvent方法里监听到事件，因为onTouch事件优先与OnTouchEvent执行，如果onTouch返回true将事件消费了,则onTouchEvent将不会执行。\n详见 （ <a href=\"http://darrenfantasy.com/2016/11/08/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/\">Android事件分发机制</a>）","source":"_posts/开发中遇到的坑.md","raw":"---\ntitle: 开发中遇到的坑\ndate: 2016-11-03 16:00:58\ntags:\n---\n\n---\n2016-11-03关于Java中Integer的值的比较\n---\n\n今天在开发中，需要新增一个错误码的返回值，调试过程中发现\n\n\n Integer i = 40002;\n Integer j = 40002;\n i==j 返回false\n \n 而之前错误码0的时候确实返回true\n Integer x = 0;\n Integer y = 0;\n x==y 返回true\n \n 一时半会有点晕，打断点的时候才发现对象不一样。\n 后来查资料发现\n<pre><code>\n public static Integer valueOf(int i) {\n        return  i >= 128 || i < -128 ? new Integer(i) : SMALL_VALUES[i + 128];\n    }\n\n    /**\n     * A cache of instances used by {@link Integer#valueOf(int)} and auto-boxing\n     */\n    private static final Integer[] SMALL_VALUES = new Integer[256];\n\n    static {\n        for (int i = -128; i < 128; i++) {\n            SMALL_VALUES[i + 128] = new Integer(i);\n        }\n    }\n </code></pre>\n 默认Integer值在－127到128区间内，就会把i作为变量存到内存里。否则会new一个Integer对象。\n 所以比较Integer值的时候，可以使用Integer.intValue()或者直接用equals()比较。\n \n---\n2017-01-12开发表情搜搜demo时遇到的一些问题\n---\n\n大约一周半的时间，完成了表情搜搜demo\n以下记录了开发中遇到的问题\n\n1.Intent无法传递太大数据\n（业务需求：把后打开的页面里的一个图片的base64传到上一个页面，由于数据量过大，后改为把图片的url传回上个页面再去转成base64）\n因为遇到要在后打开的页面传递值返回到上一个页面，所以用StartActivityForResult方法。在setResult时通过Intent来把图片的base64传回去，\n但是遇到错误信息：E/JavaBinder﹕ !!! FAILED BINDER TRANSACTION !!!\n查阅资料发现  https://developer.android.com/reference/android/os/TransactionTooLargeException.html\nThe Binder transaction buffer has a limited fixed size, currently 1Mb, which is shared by all transactions in progress for the process. Consequently this exception can be thrown when there are many transactions in progress even when most of the individual transactions are of moderate size.\nBinder事务缓冲区具有有限的固定大小，目前为1Mb，由进程正在进行的所有事务共享。因此，当有许多事务正在进行时，即使大多数单独的事务大小适中，也可以抛出此异常.\n\n\n2.SharedPreferences存StringSet时，不能直接操作取出的set.否则数据会丢失\n(业务需求：缓存本地搜索记录，因为是要存10个字符串，所以一开始想简单点直接用StringSet，后来因为set无序，所以改用拼接字符串)\n查源代码发现  *<p>Note that you <em>must not</em> modify the set instance returned\n            * by this call.  The consistency of the stored data is not guaranteed\n            * if you do, nor is your ability to modify the instance at all.\n\n3.Android 防止点击事件穿透（在布局的根节点添加Android:clickable=\"true\" 属性即可，用来获取焦点防止点击事件穿透）\n\n4.自定义view为内部类时，没有将内部类设置为static \n导致java.lang.NoSuchMethodException: <init> [class android.content.Context, interface android.util.AttributeSet]\n\n5.想监听一个父布局的ontouch事件时，发现用手触摸时只打印出Action.move和up.如果点击父布局里的子控件时，什么事件都无法打印出来。\n回想了下之前View的事件分发机制，不能在重写OnTouchEvent方法里监听到事件，因为onTouch事件优先与OnTouchEvent执行，如果onTouch返回true将事件消费了,则onTouchEvent将不会执行。\n详见 （ <a href=\"http://darrenfantasy.com/2016/11/08/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/\">Android事件分发机制</a>）","slug":"开发中遇到的坑","published":1,"updated":"2017-02-15T08:18:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6rs6q8000b1kgfo2gtopqa","content":"<hr>\n<h2 id=\"2016-11-03关于Java中Integer的值的比较\"><a href=\"#2016-11-03关于Java中Integer的值的比较\" class=\"headerlink\" title=\"2016-11-03关于Java中Integer的值的比较\"></a>2016-11-03关于Java中Integer的值的比较</h2><p>今天在开发中，需要新增一个错误码的返回值，调试过程中发现</p>\n<p> Integer i = 40002;<br> Integer j = 40002;<br> i==j 返回false</p>\n<p> 而之前错误码0的时候确实返回true<br> Integer x = 0;<br> Integer y = 0;<br> x==y 返回true</p>\n<p> 一时半会有点晕，打断点的时候才发现对象不一样。<br> 后来查资料发现</p>\n<p><pre><code><br> public static Integer valueOf(int i) {<br>        return  i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];<br>    }</code></pre></p>\n<pre><code>/**\n * A cache of instances used by {@link Integer#valueOf(int)} and auto-boxing\n */\nprivate static final Integer[] SMALL_VALUES = new Integer[256];\n\nstatic {\n    for (int i = -128; i &lt; 128; i++) {\n        SMALL_VALUES[i + 128] = new Integer(i);\n    }\n}\n</code></pre><p> <br> 默认Integer值在－127到128区间内，就会把i作为变量存到内存里。否则会new一个Integer对象。<br> 所以比较Integer值的时候，可以使用Integer.intValue()或者直接用equals()比较。</p>\n<hr>\n<h2 id=\"2017-01-12开发表情搜搜demo时遇到的一些问题\"><a href=\"#2017-01-12开发表情搜搜demo时遇到的一些问题\" class=\"headerlink\" title=\"2017-01-12开发表情搜搜demo时遇到的一些问题\"></a>2017-01-12开发表情搜搜demo时遇到的一些问题</h2><p>大约一周半的时间，完成了表情搜搜demo<br>以下记录了开发中遇到的问题</p>\n<p>1.Intent无法传递太大数据<br>（业务需求：把后打开的页面里的一个图片的base64传到上一个页面，由于数据量过大，后改为把图片的url传回上个页面再去转成base64）<br>因为遇到要在后打开的页面传递值返回到上一个页面，所以用StartActivityForResult方法。在setResult时通过Intent来把图片的base64传回去，<br>但是遇到错误信息：E/JavaBinder﹕ !!! FAILED BINDER TRANSACTION !!!<br>查阅资料发现  <a href=\"https://developer.android.com/reference/android/os/TransactionTooLargeException.html\" target=\"_blank\" rel=\"external\">https://developer.android.com/reference/android/os/TransactionTooLargeException.html</a><br>The Binder transaction buffer has a limited fixed size, currently 1Mb, which is shared by all transactions in progress for the process. Consequently this exception can be thrown when there are many transactions in progress even when most of the individual transactions are of moderate size.<br>Binder事务缓冲区具有有限的固定大小，目前为1Mb，由进程正在进行的所有事务共享。因此，当有许多事务正在进行时，即使大多数单独的事务大小适中，也可以抛出此异常.</p>\n<p>2.SharedPreferences存StringSet时，不能直接操作取出的set.否则数据会丢失<br>(业务需求：缓存本地搜索记录，因为是要存10个字符串，所以一开始想简单点直接用StringSet，后来因为set无序，所以改用拼接字符串)<br>查源代码发现  *</p><p>Note that you <em>must not</em> modify the set instance returned</p>\n<pre><code>* by this call.  The consistency of the stored data is not guaranteed\n* if you do, nor is your ability to modify the instance at all.\n</code></pre><p>3.Android 防止点击事件穿透（在布局的根节点添加Android:clickable=”true” 属性即可，用来获取焦点防止点击事件穿透）</p>\n<p>4.自定义view为内部类时，没有将内部类设置为static<br>导致java.lang.NoSuchMethodException: <init> [class android.content.Context, interface android.util.AttributeSet]</init></p>\n<p>5.想监听一个父布局的ontouch事件时，发现用手触摸时只打印出Action.move和up.如果点击父布局里的子控件时，什么事件都无法打印出来。<br>回想了下之前View的事件分发机制，不能在重写OnTouchEvent方法里监听到事件，因为onTouch事件优先与OnTouchEvent执行，如果onTouch返回true将事件消费了,则onTouchEvent将不会执行。<br>详见 （ <a href=\"http://darrenfantasy.com/2016/11/08/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"external\">Android事件分发机制</a>）</p>\n","excerpt":"","more":"<hr>\n<h2 id=\"2016-11-03关于Java中Integer的值的比较\"><a href=\"#2016-11-03关于Java中Integer的值的比较\" class=\"headerlink\" title=\"2016-11-03关于Java中Integer的值的比较\"></a>2016-11-03关于Java中Integer的值的比较</h2><p>今天在开发中，需要新增一个错误码的返回值，调试过程中发现</p>\n<p> Integer i = 40002;<br> Integer j = 40002;<br> i==j 返回false</p>\n<p> 而之前错误码0的时候确实返回true<br> Integer x = 0;<br> Integer y = 0;<br> x==y 返回true</p>\n<p> 一时半会有点晕，打断点的时候才发现对象不一样。<br> 后来查资料发现</p>\n<p><pre><code><br> public static Integer valueOf(int i) {<br>        return  i &gt;= 128 || i &lt; -128 ? new Integer(i) : SMALL_VALUES[i + 128];<br>    }</p>\n<pre><code>/**\n * A cache of instances used by {@link Integer#valueOf(int)} and auto-boxing\n */\nprivate static final Integer[] SMALL_VALUES = new Integer[256];\n\nstatic {\n    for (int i = -128; i &lt; 128; i++) {\n        SMALL_VALUES[i + 128] = new Integer(i);\n    }\n}\n</code></pre><p> </code></pre><br> 默认Integer值在－127到128区间内，就会把i作为变量存到内存里。否则会new一个Integer对象。<br> 所以比较Integer值的时候，可以使用Integer.intValue()或者直接用equals()比较。</p>\n<hr>\n<h2 id=\"2017-01-12开发表情搜搜demo时遇到的一些问题\"><a href=\"#2017-01-12开发表情搜搜demo时遇到的一些问题\" class=\"headerlink\" title=\"2017-01-12开发表情搜搜demo时遇到的一些问题\"></a>2017-01-12开发表情搜搜demo时遇到的一些问题</h2><p>大约一周半的时间，完成了表情搜搜demo<br>以下记录了开发中遇到的问题</p>\n<p>1.Intent无法传递太大数据<br>（业务需求：把后打开的页面里的一个图片的base64传到上一个页面，由于数据量过大，后改为把图片的url传回上个页面再去转成base64）<br>因为遇到要在后打开的页面传递值返回到上一个页面，所以用StartActivityForResult方法。在setResult时通过Intent来把图片的base64传回去，<br>但是遇到错误信息：E/JavaBinder﹕ !!! FAILED BINDER TRANSACTION !!!<br>查阅资料发现  <a href=\"https://developer.android.com/reference/android/os/TransactionTooLargeException.html\">https://developer.android.com/reference/android/os/TransactionTooLargeException.html</a><br>The Binder transaction buffer has a limited fixed size, currently 1Mb, which is shared by all transactions in progress for the process. Consequently this exception can be thrown when there are many transactions in progress even when most of the individual transactions are of moderate size.<br>Binder事务缓冲区具有有限的固定大小，目前为1Mb，由进程正在进行的所有事务共享。因此，当有许多事务正在进行时，即使大多数单独的事务大小适中，也可以抛出此异常.</p>\n<p>2.SharedPreferences存StringSet时，不能直接操作取出的set.否则数据会丢失<br>(业务需求：缓存本地搜索记录，因为是要存10个字符串，所以一开始想简单点直接用StringSet，后来因为set无序，所以改用拼接字符串)<br>查源代码发现  *<p>Note that you <em>must not</em> modify the set instance returned</p>\n<pre><code>* by this call.  The consistency of the stored data is not guaranteed\n* if you do, nor is your ability to modify the instance at all.\n</code></pre><p>3.Android 防止点击事件穿透（在布局的根节点添加Android:clickable=”true” 属性即可，用来获取焦点防止点击事件穿透）</p>\n<p>4.自定义view为内部类时，没有将内部类设置为static<br>导致java.lang.NoSuchMethodException: <init> [class android.content.Context, interface android.util.AttributeSet]</p>\n<p>5.想监听一个父布局的ontouch事件时，发现用手触摸时只打印出Action.move和up.如果点击父布局里的子控件时，什么事件都无法打印出来。<br>回想了下之前View的事件分发机制，不能在重写OnTouchEvent方法里监听到事件，因为onTouch事件优先与OnTouchEvent执行，如果onTouch返回true将事件消费了,则onTouchEvent将不会执行。<br>详见 （ <a href=\"http://darrenfantasy.com/2016/11/08/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/\">Android事件分发机制</a>）</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}